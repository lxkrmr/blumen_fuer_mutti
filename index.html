<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blumen fÃ¼r Mutti</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Bâ™¥M">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
      touch-action: none;
    }

    /* On actual phone: no frame */
    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script>
// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// â”€â”€ i18n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STRINGS = {
  de: {
    lang_toggle:        'EN',
    building_one:       'Harry baut 1 Blume â€¦',
    building_many:      (n) => `Harry baut ${n} Blumen â€¦`,
    building_idle_mine: 'teile sortieren um blumen zu erschaffen',
  },
  en: {
    lang_toggle:        'DE',
    building_one:       'Harry is building 1 flower â€¦',
    building_many:      (n) => `Harry is building ${n} flowers â€¦`,
    building_idle_mine: 'sort parts to grow flowers',
  },
};

let lang = localStorage.getItem('bfm-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Flower recipe â€“ how many sorted shards per bin make one flower part
const FLOWER_RECIPE = { circle: 1, heart: 8, stem: 3, leaf: 2 };
const BUILD_BASE_MS      = 20000;   // base build time in ms (Â±15% random variance)
const BOUQUET_MAX        = 10;      // flowers per bouquet before sending to Mutti
const BOUQUET_COIN_VALUE = 100;     // coins earned when Mutti sells a bouquet
let   flowerIdCounter = 0;

const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// â”€â”€ Shapes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SHAPES = [
  { id: 'circle' },
  { id: 'heart'  },
  { id: 'stem'   },
  { id: 'leaf'   },
];

// Weighted shape spawn â€“ probabilities match recipe ratios (total 14 parts)
const SHAPE_WEIGHTS = [
  { shape: SHAPES[0], w: 1 },   // circle  1/14
  { shape: SHAPES[1], w: 8 },   // heart   8/14
  { shape: SHAPES[2], w: 3 },   // stem    3/14
  { shape: SHAPES[3], w: 2 },   // leaf    2/14
];
const SHAPE_WEIGHT_TOTAL = SHAPE_WEIGHTS.reduce((s, e) => s + e.w, 0);

function randomShape() {
  let r = Math.random() * SHAPE_WEIGHT_TOTAL;
  for (const entry of SHAPE_WEIGHTS) {
    r -= entry.w;
    if (r <= 0) return entry.shape;
  }
  return SHAPE_WEIGHTS[SHAPE_WEIGHTS.length - 1].shape;
}

// â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HEADER_H    = 50;
const INDICATOR_R = 80;
const INDICATOR_CX = W / 2;                                      // 215
const INDICATOR_CY = HEADER_H + INDICATOR_R + 10;                // 140
const BIN_H     = 96,  BIN_W = 80, BIN_GAP = 12, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;                               // 800
const BIN_TOTAL = 4 * BIN_W + 3 * BIN_GAP;                      // 356
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                          // 37
const PLAY_Y    = INDICATOR_CY + INDICATOR_R + 32;               // 252
const PLAY_H    = BIN_Y - PLAY_Y - 20;                          // 528
const PLAY_CX   = W / 2;                                        // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                          // ~516
// Aliases used in drawIndicator
const GEM_CX    = INDICATOR_CX;
const GEM_CY    = INDICATOR_CY;
const GEM_R     = INDICATOR_R;

// Shard landing zones â€“ offsets from play-area center (12 for jackpot blocks)
const SHARD_ZONES = [
  { dx:    0, dy: -115 },
  { dx: -100, dy:  -55 },
  { dx: -100, dy:   60 },
  { dx:    0, dy:  115 },
  { dx:  100, dy:   60 },
  { dx:  100, dy:  -55 },
  { dx:  -45, dy: -160 },
  { dx:   45, dy: -155 },
  { dx: -160, dy:   10 },
  { dx:  155, dy:   15 },
  { dx:  -55, dy:  165 },
  { dx:   60, dy:  160 },
];

const SHARD_SIZE = 60;

// Block sizes â€“ size = yield + hardness. Bigger = more taps + more shards.
const SIZES = [
  { id: 'small',   blockPx:  90, shards:  3, taps: [1,  2] },
  { id: 'medium',  blockPx: 118, shards:  5, taps: [2,  4] },
  { id: 'large',   blockPx: 150, shards:  7, taps: [4,  7] },
  { id: 'jackpot', blockPx: 188, shards: 12, taps: [7, 12] },
];


// â”€â”€ Pfingstrose color system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PEONY_PETAL_POOL = [
  '#fce4ec', '#f8bbd9', '#f48fb1', '#f06292',
  '#e91e8c', '#c2185b', '#880e4f',
];

// Slightly shift a hex color by Â±range per channel â€“ keeps colors organic
function varyColor(hex, range = 12) {
  const p = (i) => parseInt(hex.slice(i, i + 2), 16);
  const r = p(1), g = p(3), b = p(5);
  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  const vary  = () => (Math.random() - 0.5) * 2 * range;
  return '#' + [r + vary(), g + vary(), b + vary()]
    .map(v => clamp(v).toString(16).padStart(2, '0')).join('');
}

// Maps a shape to its Pfingstrose color
function shapeToColor(shapeId) {
  switch (shapeId) {
    case 'circle': return varyColor('#fff176', 10);
    case 'heart':  return PEONY_PETAL_POOL[Math.floor(Math.random() * PEONY_PETAL_POOL.length)];
    case 'stem':   return varyColor('#52b788', 12);
    case 'leaf':   return varyColor('#1e4d2b', 10);
    default:       return '#ffffff';
  }
}

// â”€â”€ Easing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

// Format coins with locale-aware thousand separator (DE: 1.250, EN: 1,250)
function formatCoins(n) {
  return n.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US');
}

// â”€â”€ Haptics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// Button bounds â€“ set each frame during draw, used by hitTest
let langBtnBounds = null;

// â”€â”€ Drag state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const drag = {
  active:  false,
  shardId: null,
  x:       0,
  y:       0,
};

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let shardIdCounter = 0;

const state = {
  phase:    'block',   // 'block' | 'shards'
  block:    null,
  shards:   [],
  selected: null,
  bins:     SHAPES.map(s => ({ shape: s, shards: [] })),
};

// Flower system â€“ separate from game state
const flowers = {
  building: [],   // { id, parts } â€“ currently growing
  bouquet:  [],   // { id, parts } â€“ finished, up to BOUQUET_MAX
  coins:    0,    // coins earned from bouquets sold by Mutti
};

// Build timer â€“ runtime only, not persisted
let buildTimerActive = false;
let buildStartedAt   = 0;   // performance.now() â€“ resets on each page load
let buildDurationMs  = 0;   // for progress ring

// â”€â”€ Animation state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let blockEnterStart = 0;
const binFillAnim   = Array(4).fill(0);  // lerps toward fill target (0â†’1, clamps at 1)
const binFlashAt    = Array(4).fill(0);  // timestamp of last recipe-threshold event

// â”€â”€ Game logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

// Piece positions for N shapes in a cluster â€“ normalized offsets scaled by spread
const PIECE_LAYOUTS = {
   3: [[ 0,   -1  ], [-0.9,  0.7 ], [ 0.9,  0.7 ]],
   5: [[ 0,   -1  ], [-0.95,-0.3 ], [-0.6,  0.85], [ 0.6,  0.85], [ 0.95,-0.3 ]],
   7: [[ 0,    0  ], [ 0,   -1.3 ], [ 1.1, -0.65], [ 1.1,  0.65], [ 0,   1.3 ], [-1.1, 0.65], [-1.1, -0.65]],
  12: [[-0.6, -0.6], [ 0.6, -0.6 ], [-0.6,  0.6 ], [ 0.6,  0.6 ],
       [ 0,   -1.4], [ 1.2, -0.7 ], [ 1.4,  0   ], [ 1.2,  0.7 ],
       [ 0,    1.4], [-1.2,  0.7 ], [-1.4,  0   ], [-1.2, -0.7 ]],
};

function genPieces(count, blockPx) {
  const spread    = blockPx * 0.17;
  const pieceSize = blockPx * 0.58;
  return PIECE_LAYOUTS[count].map(([nx, ny]) => {
    const shape = randomShape();
    return {
      shape,
      color: shapeToColor(shape.id),
      x:     nx * spread + (Math.random() - 0.5) * spread * 0.3,
      y:     ny * spread + (Math.random() - 0.5) * spread * 0.3,
      size:  pieceSize,
      angle: (Math.random() - 0.5) * 0.5,   // Â±~15Â°
    };
  });
}

function spawnBlock() {
  state.phase    = 'block';
  state.shards   = [];
  state.selected = null;

  const size  = SIZES[Math.floor(Math.random() * SIZES.length)];
  const [tMin, tMax] = size.taps;
  const tapsRequired = tMin + Math.floor(Math.random() * (tMax - tMin + 1));

  state.block = {
    size,
    pieces:       genPieces(size.shards, size.blockPx),
    tapsRequired, tapsLeft: tapsRequired,
    lastTapAt: 0, angle: 0,
  };
  blockEnterStart = performance.now();
}

function tapBlock() {
  if (state.phase !== 'block') return;
  const block = state.block;

  block.lastTapAt    = performance.now();
  block.angle += (Math.random() - 0.5) * 0.25;
  block.tapsLeft--;

  if (block.tapsLeft <= 0) {
    haptic([10, 20, 10]);
    doBreakBlock();
  } else {
    haptic(8);
  }
}

function doBreakBlock() {
  if (state.phase !== 'block') return;

  state.phase = 'shards';
  const now   = performance.now();
  const zones = [...SHARD_ZONES].sort(() => Math.random() - 0.5);

  state.block.pieces.forEach((piece, i) => {
    state.shards.push({
      id:         shardIdCounter++,
      color:      { hex: piece.color },
      shape:      piece.shape,
      targetX:    PLAY_CX + jitter(zones[i].dx),
      targetY:    PLAY_CY + jitter(zones[i].dy),
      flyStart:   now,
      phase:      'flying',
      sortStart:  0,
      shakeStart: 0,
    });
  });
}

function trySortShard(binIndex) {
  if (state.selected === null) return;

  const shard = state.shards.find(s => s.id === state.selected);
  if (!shard) return;

  if (shard.shape.id !== state.bins[binIndex].shape.id) {
    // Wrong bin â€“ place at drop position, shake for feedback
    haptic([8, 30, 8]);
    shard.targetX   = drag.x;
    shard.targetY   = drag.y;
    shard.phase     = 'idle';
    shard.shakeStart = performance.now();
    state.selected  = null;
    return;
  }

  // âœ“ Correct sort â€“ animate from drop position (prevents flash at origin)
  haptic(12);
  shard.targetX   = drag.x;
  shard.targetY   = drag.y;
  shard.phase     = 'sorting';
  shard.sortStart = performance.now();
  state.selected  = null;

  setTimeout(() => {
    state.shards = state.shards.filter(s => s.id !== shard.id);

    const bin    = state.bins[binIndex];
    const recipe = FLOWER_RECIPE[bin.shape.id];
    bin.shards.push({ color: shard.color.hex });

    // Flash when we cross a recipe threshold
    if (bin.shards.length % recipe === 0) {
      binFlashAt[binIndex] = performance.now();
      haptic([18, 10, 18]);
    }

    checkBuildTrigger();

    if (state.shards.length === 0) {
      setTimeout(spawnBlock, 350);
    }
    saveState();
  }, 230);
}

// â”€â”€ Flower system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function flowersReady() {
  return Math.min(...SHAPES.map(s => {
    const bin = state.bins.find(b => b.shape.id === s.id);
    return Math.floor(bin.shards.length / FLOWER_RECIPE[s.id]);
  }));
}

function checkBuildTrigger() {
  while (flowersReady() > 0) {
    // Consume shards from bins
    for (const s of SHAPES) {
      state.bins.find(b => b.shape.id === s.id).shards.splice(0, FLOWER_RECIPE[s.id]);
    }

    // Assign Pfingstrose colors via shapeToColor
    const parts = {
      circle: [{ color: shapeToColor('circle') }],
      heart:  Array.from({ length: 8 }, () => ({ color: shapeToColor('heart') })),
      stem:   Array.from({ length: 3 }, () => ({ color: shapeToColor('stem')  })),
      leaf:   Array.from({ length: 2 }, () => ({ color: shapeToColor('leaf')  })),
    };
    flowers.building.push({ id: flowerIdCounter++, parts });
    haptic([15, 10, 15]);
  }

  if (flowers.building.length > 0 && !buildTimerActive) {
    startBuildTimer();
  }
  saveState();
}

function startBuildTimer() {
  if (buildTimerActive || flowers.building.length === 0) return;

  buildTimerActive = true;
  buildDurationMs  = BUILD_BASE_MS * (0.85 + Math.random() * 0.3);
  buildStartedAt   = performance.now(); // For progress ring, not persisted

  setTimeout(completeBuilding, buildDurationMs);
}

function completeBuilding() {
  const flower = flowers.building.shift();
  if (!flower) return;

  flowers.bouquet.push({ id: flower.id, parts: flower.parts });

  if (flowers.bouquet.length >= BOUQUET_MAX) {
    // Bouquet complete â€“ Mutti sells it and sends coins!
    flowers.coins += BOUQUET_COIN_VALUE;
    flowers.bouquet = [];
    haptic([20, 12, 20, 12, 35, 15, 50]);
  } else {
    haptic([20, 12, 20, 12, 35]);
  }

  buildTimerActive = false;
  checkBuildTrigger(); // Will save state
}

// â”€â”€ Shard animation helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns { x, y, scale, opacity } for the current frame
function shardAnim(shard, now) {
  if (shard.phase === 'flying') {
    const t = clamp01((now - shard.flyStart) / 450);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(PLAY_CX, shard.targetX, e),
      y:       lerp(PLAY_CY, shard.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (shard.phase === 'sorting') {
    const t = clamp01((now - shard.sortStart) / 220);
    return { x: shard.targetX, y: shard.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  if (shard.phase === 'dragging') {
    return { x: drag.x, y: drag.y, scale: 1.18, opacity: 1 };
  }

  // idle â€“ optional shake
  let shakeX = 0;
  if (shard.shakeStart) {
    const st = clamp01((now - shard.shakeStart) / 350);
    shakeX = Math.sin(st * Math.PI * 4.5) * 12 * (1 - st);
    if (st >= 1) shard.shakeStart = 0;
  }

  return { x: shard.targetX + shakeX, y: shard.targetY, scale: 1, opacity: 1 };
}

// â”€â”€ Shape paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pathCircle(ctx, cx, cy, s) {
  ctx.arc(cx, cy, s * 0.42, 0, Math.PI * 2);
}

function pathHeart(ctx, cx, cy, s) {
  const r = s * 0.42;
  const x = cx, y = cy + r * 0.2;
  ctx.moveTo(x, y + r * 0.75);
  ctx.bezierCurveTo(x - r * 0.1, y + r * 0.4,  x - r, y + r * 0.1,  x - r, y - r * 0.3);
  ctx.bezierCurveTo(x - r, y - r,               x,     y - r * 0.65, x,     y - r * 0.1);
  ctx.bezierCurveTo(x,     y - r * 0.65,        x + r, y - r,        x + r, y - r * 0.3);
  ctx.bezierCurveTo(x + r, y + r * 0.1,         x + r * 0.1, y + r * 0.4, x, y + r * 0.75);
}

function pathStem(ctx, cx, cy, s) {
  const w = s * 0.22, h = s * 0.46;
  ctx.roundRect(cx - w, cy - h, w * 2, h * 2, w);
}

function pathLeaf(ctx, cx, cy, s) {
  const h = s * 0.46, w = s * 0.28;
  ctx.moveTo(cx - h, cy);
  ctx.bezierCurveTo(cx - h * 0.3, cy - w, cx + h * 0.3, cy - w, cx + h, cy);
  ctx.bezierCurveTo(cx + h * 0.3, cy + w, cx - h * 0.3, cy + w, cx - h, cy);
}

function drawShapePath(ctx, shape, cx, cy, size) {
  ctx.beginPath();
  switch (shape.id) {
    case 'circle': pathCircle(ctx, cx, cy, size); break;
    case 'heart':  pathHeart(ctx, cx, cy, size);  break;
    case 'stem':   pathStem(ctx, cx, cy, size);   break;
    case 'leaf':   pathLeaf(ctx, cx, cy, size);   break;
  }
  ctx.closePath();
}

// â”€â”€ Hit testing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

function hitTest(x, y, now) {
  // Lang button
  if (langBtnBounds && inRect(x, y, langBtnBounds.x, langBtnBounds.y, langBtnBounds.w, langBtnBounds.h)) {
    return { type: 'lang' };
  }

  // Shards (reverse so topmost is checked first)
  if (state.phase === 'shards') {
    for (const shard of [...state.shards].reverse()) {
      if (shard.phase === 'sorting') continue;
      const a  = shardAnim(shard, now);
      const dx = x - a.x, dy = y - a.y;
      if (Math.sqrt(dx * dx + dy * dy) < SHARD_SIZE * 0.45 * a.scale) {
        return { type: 'shard', id: shard.id };
      }
    }
  }

  // Block
  if (state.phase === 'block') {
    const hw = state.block.size.blockPx / 2;
    if (inRect(x, y, PLAY_CX - hw, PLAY_CY - hw, state.block.size.blockPx, state.block.size.blockPx)) {
      return { type: 'block' };
    }
  }

  // Bins
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(x, y, bx, BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTouchEnd = 0;

function initDrag(coords) {
  const now = performance.now();
  const hit = hitTest(coords.x, coords.y, now);
  if (!hit || hit.type !== 'shard') return;

  const shard = state.shards.find(s => s.id === hit.id);
  if (!shard || shard.phase === 'sorting') return;

  haptic(8);
  drag.active  = true;
  drag.shardId = hit.id;
  drag.x       = coords.x;
  drag.y       = coords.y;
  shard.phase  = 'dragging';
  state.selected = null;
}

function updateDrag(coords) {
  if (!drag.active) return;
  drag.x = coords.x;
  drag.y = coords.y;
}

function endDrag(coords) {
  if (!drag.active) return;
  drag.active = false;

  const shard = state.shards.find(s => s.id === drag.shardId);
  drag.shardId = null;
  if (!shard) return;

  // Check if dropped on a bin
  let binIndex = -1;
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(coords.x, coords.y, bx, BIN_Y, BIN_W, BIN_H)) { binIndex = i; break; }
  }

  if (binIndex >= 0) {
    state.selected = shard.id;
    trySortShard(binIndex);
    // trySortShard always resolves the shard phase
    return;
  }

  // Dropped on empty space â€“ place freely at drop position
  shard.targetX  = coords.x;
  shard.targetY  = coords.y;
  shard.phase    = 'idle';
  state.selected = null;
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updateDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
}, { passive: false });

canvas.addEventListener('mousedown',  (e) => { initDrag(canvasCoords(e)); });
canvas.addEventListener('mousemove',  (e) => { updateDrag(canvasCoords(e)); });
canvas.addEventListener('mouseup',    (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'lang':  toggleLang(); break;
    case 'block': tapBlock();   break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('bfm-lang', lang);
}

// â”€â”€ Flower draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFlower(ctx, cx, cy, rotation, scale, parts) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  ctx.scale(scale, scale);
  ctx.translate(0, -58); // origin = bottom of stem

  // Extract colors (with fallbacks)
  const circleColor = parts.circle && parts.circle[0] ? parts.circle[0].color : '#fff176';
  const heartColors = parts.heart || [];
  const stemColors  = parts.stem  || [];
  const leafColors  = parts.leaf  || [];
  const hc = i => heartColors[i] ? heartColors[i].color : '#f48fb1';
  const sc = i => stemColors[i]  ? stemColors[i].color  : '#52b788';
  const lc = i => leafColors[i]  ? leafColors[i].color  : '#1e4d2b';

  // â”€â”€ Right leaf behind stem â€“ outer tip points upper-right â”€â”€
  ctx.save();
  ctx.translate(10, 44);
  ctx.rotate(-0.8);
  ctx.fillStyle = lc(1);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // â”€â”€ Stem (3 segments as stroked lines â€“ guaranteed connected, per-segment color) â”€â”€
  const kinks = [ {x:2,y:15}, {x:7,y:30}, {x:0,y:45}, {x:3,y:58} ];
  ctx.lineWidth = 5;
  ctx.lineCap   = 'round';
  ctx.lineJoin  = 'round';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.strokeStyle = sc(i);
    ctx.moveTo(kinks[i].x,   kinks[i].y);
    ctx.lineTo(kinks[i+1].x, kinks[i+1].y);
    ctx.stroke();
  }
  ctx.lineCap  = 'butt';
  ctx.lineJoin = 'miter';

  // â”€â”€ Left leaf in front of stem â€“ outer tip points upper-left â”€â”€
  ctx.save();
  ctx.translate(-8, 30);
  ctx.rotate(0.8);
  ctx.fillStyle = lc(0);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // â”€â”€ Petal base â€“ solid circle to block bleed-through from behind â”€â”€
  ctx.fillStyle = hc(0);
  ctx.beginPath(); pathCircle(ctx, 0, 0, 27); ctx.fill();

  // â”€â”€ Petals: 8 hearts in a ring, tips toward center â”€â”€
  const PETAL_R    = 17;
  const PETAL_SIZE = 20;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    ctx.save();
    ctx.translate(Math.cos(angle) * PETAL_R, Math.sin(angle) * PETAL_R);
    ctx.rotate(angle + Math.PI / 2);   // rotate so tip points toward center
    ctx.fillStyle = hc(i);
    ctx.beginPath(); pathHeart(ctx, 0, 0, PETAL_SIZE); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // â”€â”€ Center circle â”€â”€
  ctx.fillStyle = circleColor;
  ctx.beginPath(); pathCircle(ctx, 0, 0, 14); ctx.fill();

  ctx.restore();
}

// â”€â”€ Draw functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// Draws the bouquet of finished flowers around the indicator anchor
function drawBouquet(cx, cy) {
  const n = flowers.bouquet.length;
  if (n === 0) return;

  const FAN_RAD     = 70 * Math.PI / 180;  // Â±35Â° total spread
  const BOUQ_SCALE  = 1.0;

  for (let i = 0; i < n; i++) {
    const t        = n === 1 ? 0 : (i / (n - 1) - 0.5);
    const rotation = t * FAN_RAD;
    drawFlower(ctx, cx, cy, rotation, BOUQ_SCALE, flowers.bouquet[i].parts);
  }
}

function drawIndicator(now) {
  const active = buildTimerActive || flowers.building.length > 0;
  const cx = GEM_CX, cy = GEM_CY, r = GEM_R;

  // Progress through current build (0â€“1), runtime only
  const progress = buildTimerActive
    ? clamp01((now - buildStartedAt) / buildDurationMs)
    : 0;

  // Pulse factor (only when active)
  const pulse = active ? 0.6 + 0.4 * Math.sin(now / 700) : 0;

  // Draw bouquet â€“ anchor shifted down so blooms sit in upper portion of circle
  drawBouquet(cx, cy + 38);

  // Circle background (subtle, over stem bases)
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = active ? `rgba(13,17,23,${0.55 + pulse * 0.05})` : 'rgba(13,17,23,0.55)';
  ctx.fill();

  // Track ring
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 3;
  ctx.stroke();

  // Progress arc
  if (active) {
    ctx.shadowColor = '#58a6ff';
    ctx.shadowBlur  = 10 + 8 * pulse;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth   = 3;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Center dot when circle is empty and idle
  if (flowers.bouquet.length === 0 && flowers.coins === 0) {
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = active ? `rgba(88,166,255,${0.4 + pulse * 0.6})` : 'rgba(110,118,129,0.3)';
    ctx.fill();
  }

  // Coins badge â€“ pill overlapping the bottom of the circle ring
  if (flowers.coins > 0 || flowers.bouquet.length > 0) {
    const badgeY = cy + r;           // sits right on the ring bottom
    const ph = 22, pad = 12;
    ctx.font = '12px system-ui';

    // Build the two text segments
    const coinStr  = flowers.coins > 0 ? `ðŸ’° ${formatCoins(flowers.coins)}` : '';
    const sepStr   = flowers.coins > 0 ? '  ' : '';
    const countStr = `${flowers.bouquet.length} / ${BOUQUET_MAX}`;
    const coinW    = ctx.measureText(coinStr + sepStr).width;
    const countW   = ctx.measureText(countStr).width;
    const totalW   = (flowers.coins > 0 ? coinW : 0) + countW;
    const pw       = totalW + pad * 2;
    const px       = cx - pw / 2;
    const py       = badgeY - ph / 2;

    // Pill background
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, ph / 2);
    ctx.fill();
    ctx.strokeStyle = BORDER;
    ctx.lineWidth   = 1;
    ctx.beginPath();
    ctx.roundRect(px, py, pw, ph, ph / 2);
    ctx.stroke();

    // Text: coins in gold, bouquet progress in dim
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'left';
    const textStartX = cx - totalW / 2;
    if (flowers.coins > 0) {
      ctx.fillStyle = '#e3b341';
      ctx.fillText(coinStr + sepStr, textStartX, badgeY);
      ctx.fillStyle = TEXT_DIM;
      ctx.fillText(countStr, textStartX + coinW, badgeY);
    } else {
      ctx.fillStyle = TEXT_DIM;
      ctx.fillText(countStr, textStartX, badgeY);
    }
    ctx.textAlign = 'left';
  }

  // Label below badge
  ctx.fillStyle    = TEXT_DIM;
  ctx.font         = '11px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'alphabetic';
  let label;
  if (flowers.building.length > 1) {
    label = t('building_many', flowers.building.length);
  } else if (flowers.building.length === 1) {
    label = t('building_one');
  } else {
    label = t('building_idle_mine');
  }
  ctx.fillText(label, cx, cy + r + 32);
  ctx.textAlign = 'left';
}

function drawHeader() {
  // Bâ™¥M logo left
  ctx.fillStyle    = TEXT_HI;
  ctx.font         = 'bold 18px system-ui';
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillStyle    = '#f48fb1';
  ctx.fillText('B', 22, HEADER_H / 2);
  const bw = ctx.measureText('B').width;
  ctx.fillStyle = '#f06292';
  ctx.fillText('â™¥', 22 + bw, HEADER_H / 2);
  const hw = ctx.measureText('â™¥').width;
  ctx.fillStyle = TEXT_HI;
  ctx.fillText('M', 22 + bw + hw, HEADER_H / 2);
  ctx.textAlign = 'left';

  drawLangButton();
}

function drawLangButton() {
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 6);
  ctx.stroke();

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawMine(now) {
  drawHeader();
  drawIndicator(now);
  drawBlock(now);
  drawBins(now);
  drawShards(now, false);
  drawShards(now, true);
}

function drawBlock(now) {
  if (state.phase !== 'block' || !state.block) return;

  const block = state.block;

  // Enter animation
  const enterT  = clamp01((now - blockEnterStart) / 300);
  const enterSc = easeOutBack(enterT);

  // Tap wobble: scale punch + rotation rattle, both decay together
  const wobbleAge = block.lastTapAt > 0 ? now - block.lastTapAt : Infinity;
  const wobbleT   = wobbleAge < 220 ? clamp01(wobbleAge / 220) : 1;
  const wobbleSc  = wobbleAge < 220 ? 1 + Math.sin(wobbleT * Math.PI) * 0.09 : 1;
  const wobbleRot = block.angle;

  // Damage progress (0 = fresh, approaches 1 as taps run out)
  const progress = 1 - block.tapsLeft / block.tapsRequired;

  // Piece drift: spread further with each tap
  const drift = 1 + progress * 0.9;


  const sc = enterSc * wobbleSc;

  // Draw pieces with block-level rotation
  ctx.save();
  ctx.translate(PLAY_CX, PLAY_CY);
  ctx.rotate(wobbleRot);
  // Pass 1 â€“ glow halo (only after first tap, doesn't blur the shapes themselves)
  if (progress > 0) {
    const pulse = 0.55 + 0.45 * Math.sin(now / (180 - progress * 110));
    for (const piece of block.pieces) {
      ctx.save();
      ctx.translate(piece.x * sc * drift, piece.y * sc * drift);
      ctx.rotate(piece.angle);
      ctx.shadowColor = piece.color;
      ctx.shadowBlur  = progress * 34 * pulse;
      ctx.fillStyle   = piece.color;
      drawShapePath(ctx, piece.shape, 0, 0, piece.size * sc);
      ctx.fill();
      ctx.restore();
    }
  }

  // Pass 2 â€“ sharp shapes on top
  for (const piece of block.pieces) {
    ctx.save();
    ctx.translate(piece.x * sc * drift, piece.y * sc * drift);
    ctx.rotate(piece.angle);
    ctx.fillStyle = piece.color;
    drawShapePath(ctx, piece.shape, 0, 0, piece.size * sc);
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

function drawShards(now, dragOnly = false) {
  for (const shard of state.shards) {
    const isDragged = shard.phase === 'dragging';
    if (dragOnly !== isDragged) continue;
    const a = shardAnim(shard, now);
    if (a.opacity < 0.01) continue;

    ctx.globalAlpha = a.opacity;
    if (shard.phase === 'dragging') {
      ctx.shadowColor = shard.color.hex;
      ctx.shadowBlur  = 22;
    }

    ctx.fillStyle = shard.color.hex;
    drawShapePath(ctx, shard.shape, a.x, a.y, SHARD_SIZE * a.scale);
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 4; i++) {
    const bin    = state.bins[i];
    const bx     = BIN_LEFT + i * (BIN_W + BIN_GAP);
    const by     = BIN_Y;
    const recipe = FLOWER_RECIPE[bin.shape.id];
    const count  = bin.shards.length;

    // Fill target: grows 0â†’1 as count reaches recipe, then stays at 1 (no cycling)
    const fillTarget = Math.min(count / recipe, 1);
    binFillAnim[i] += (fillTarget - binFillAnim[i]) * 0.15;

    // Flash factor after hitting a recipe threshold
    const flashAge = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash    = flashAge < 600 ? 1 - flashAge / 600 : 0;

    // Background tint â€“ more saturated when bin has extra stock beyond 1 recipe
    const extras    = Math.max(0, count - recipe);
    const tintAlpha = Math.min(extras / recipe, 1) * 0.18;
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.fill();

    if (tintAlpha > 0) {
      ctx.globalAlpha = tintAlpha;
      ctx.fillStyle   = '#58a6ff';
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Fill bar â€“ fills once to 100% when count reaches recipe, stays full beyond
    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.18 + flash * 0.35;
      ctx.fillStyle   = TEXT_HI;
      const fillH = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Border
    if (flash > 0) { ctx.shadowColor = TEXT_HI; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = flash > 0 ? TEXT_HI : BORDER;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // Shape icon
    ctx.globalAlpha = 0.3 + flash * 0.5;
    ctx.fillStyle   = TEXT_HI;
    drawShapePath(ctx, bin.shape, bx + BIN_W / 2, by + BIN_H / 2, 30);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Counter below bin: "count / recipe" â€“ bright when full or over, dim when filling
    const isFull = count >= recipe;
    ctx.font         = '11px system-ui';
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle    = TEXT_HI;
    ctx.globalAlpha  = isFull ? (0.7 + flash * 0.3) : 0.35;
    ctx.fillText(`${count} / ${recipe}`, bx + BIN_W / 2, by + BIN_H + 6);
    ctx.globalAlpha  = 1;
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
  }
}

// â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw(now) {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawMine(now);
  requestAnimationFrame(draw);
}

// â”€â”€ Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAVE_KEY = 'bfm-save';

function saveState() {
  const saveData = {
    bins:           state.bins,
    building:       flowers.building,
    bouquet:        flowers.bouquet,
    coins:          flowers.coins,
    flowerIdCounter,
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
}

function loadState() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return;

  try {
    const saveData = JSON.parse(raw);
    if (!saveData) return;

    state.bins       = saveData.bins     || SHAPES.map(s => ({ shape: s, shards: [] }));
    flowers.building = saveData.building || [];
    flowers.bouquet  = saveData.bouquet  || [];
    flowers.coins    = saveData.coins    || 0;
    flowerIdCounter  = saveData.flowerIdCounter || 0;

  } catch (e) {
    console.error('Failed to load state', e);
  }
}


// â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

loadState();
checkBuildTrigger(); // In case there are flowers in build queue from last session
spawnBlock();
requestAnimationFrame(draw);
</script>

</body>
</html>

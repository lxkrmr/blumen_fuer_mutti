<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>knack!</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="knack!">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
      touch-action: none;
    }

    /* On actual phone: no frame */
    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script>
// ── Canvas setup ───────────────────────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// ── i18n ──────────────────────────────────────────────────────────────────
const STRINGS = {
  de: {
    lang_toggle: 'EN',
    gem_label:   (n, max) => `${n} von ${max} Facetten`,
    gem_done:    '✦ Edelstein vollständig!',
  },
  en: {
    lang_toggle: 'DE',
    gem_label:   (n, max) => `${n} of ${max} facets`,
    gem_done:    '✦ gem complete!',
  },
};

let lang = localStorage.getItem('knack-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// ── Colors ─────────────────────────────────────────────────────────────────
const COLORS = [
  { id: 'blue',   hex: '#58a6ff', taps: [1, 2] },
  { id: 'orange', hex: '#f0883e', taps: [2, 4] },
  { id: 'purple', hex: '#bc8cff', taps: [4, 7] },
];

// Each gem facet cycles through the 3 colors
const FACET_COLORS = ['#58a6ff', '#f0883e', '#bc8cff', '#58a6ff', '#f0883e', '#bc8cff'];

const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// ── Shapes ─────────────────────────────────────────────────────────────────
const SHAPES = [
  { id: 'circle' },
  { id: 'heart'  },
  { id: 'stem'   },
  { id: 'leaf'   },
];

// ── Layout ─────────────────────────────────────────────────────────────────
const HEADER_H  = 70;
const GEM_H     = 130;
const BIN_H     = 96,  BIN_W = 80, BIN_GAP = 12, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;
const BIN_TOTAL = 4 * BIN_W + 3 * BIN_GAP;             // 356
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                 // 37
const PLAY_Y    = HEADER_H + GEM_H;                    // 200
const PLAY_H    = BIN_Y - PLAY_Y - 20;                 // 580
const PLAY_CX   = W / 2;                               // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                 // 490
const GEM_CX    = W / 2;
const GEM_CY    = HEADER_H + GEM_H / 2 - 10;           // 125
const GEM_R     = 38;

// Shard landing zones – offsets from play-area center
const SHARD_ZONES = [
  { dx: -95, dy: -80 },
  { dx:  95, dy: -65 },
  { dx:   0, dy: 100 },
];

const SHARD_SIZE   = 80;
const BLOCK_SIZE   = 112;
const BLOCK_R      = 22;

// ── Game constants ─────────────────────────────────────────────────────────
const SHARDS_PER_BLOCK = 3;
const BIN_CAPACITY     = 4;
const GEM_FACETS       = 6;

// ── Easing ────────────────────────────────────────────────────────────────
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

// ── Haptics ───────────────────────────────────────────────────────────────
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// ── Drag state ────────────────────────────────────────────────────────────
const drag = {
  active:  false,
  shardId: null,
  x:       0,
  y:       0,
};

// ── Game state ────────────────────────────────────────────────────────────
let shardIdCounter = 0;

const state = {
  phase:    'block',   // 'block' | 'shards'
  block:    null,      // { color }
  shards:   [],        // see spawnShards()
  selected: null,      // shard id or null
  bins:     SHAPES.map(s => ({ shape: s, count: 0 })),
  gem:      { filled: 0 },
};

// ── Animation state ───────────────────────────────────────────────────────
let blockEnterStart = 0;
const binFillAnim   = Array(4).fill(0);  // lerps toward bin.count / BIN_CAPACITY
const binFlashAt    = Array(4).fill(0);  // timestamp of last bin-full event
const facetAnim     = Array(GEM_FACETS).fill(0.1);
let gemCompleteAt   = 0;

// ── Game logic ────────────────────────────────────────────────────────────
function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

function spawnBlock() {
  state.phase    = 'block';
  state.shards   = [];
  state.selected = null;

  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  const [tMin, tMax] = color.taps;
  const tapsRequired = tMin + Math.floor(Math.random() * (tMax - tMin + 1));

  state.block    = { color, tapsRequired, tapsLeft: tapsRequired, cracks: [], lastTapAt: 0 };
  blockEnterStart = performance.now();
}

function addCracks(block, n) {
  const hw = BLOCK_SIZE / 2 * 0.88;
  for (let i = 0; i < n; i++) {
    const angle = Math.random() * Math.PI * 2;
    block.cracks.push({
      x1: Math.cos(angle) * hw * Math.random() * 0.2,
      y1: Math.sin(angle) * hw * Math.random() * 0.2,
      x2: Math.cos(angle) * hw * (0.5 + Math.random() * 0.5),
      y2: Math.sin(angle) * hw * (0.5 + Math.random() * 0.5),
    });
  }
}

function tapBlock() {
  if (state.phase !== 'block') return;
  const block = state.block;

  block.lastTapAt = performance.now();
  block.tapsLeft--;

  if (block.tapsLeft <= 0) {
    haptic([10, 20, 10]);
    doBreakBlock();
  } else {
    haptic(8);
    const progress = 1 - block.tapsLeft / block.tapsRequired;
    addCracks(block, 2 + Math.floor(progress * 3));
  }
}

function doBreakBlock() {
  if (state.phase !== 'block') return;

  state.phase = 'shards';
  const now   = performance.now();
  const color = state.block.color;
  const zones = [...SHARD_ZONES].sort(() => Math.random() - 0.5);

  zones.slice(0, SHARDS_PER_BLOCK).forEach(zone => {
    state.shards.push({
      id:         shardIdCounter++,
      color,
      shape:      SHAPES[Math.floor(Math.random() * SHAPES.length)],
      targetX:    PLAY_CX + jitter(zone.dx),
      targetY:    PLAY_CY + jitter(zone.dy),
      flyStart:   now,
      phase:      'flying',   // 'flying' | 'idle' | 'dragging' | 'snapping' | 'sorting'
      sortStart:  0,
      shakeStart: 0,
    });
  });
}

function selectShard(id) {
  haptic(8);

  if (state.selected === id) {
    // Tap same shard → deselect
    const s = state.shards.find(s => s.id === id);
    if (s) s.phase = 'idle';
    state.selected = null;
    return;
  }

  // Deselect previous
  if (state.selected !== null) {
    const prev = state.shards.find(s => s.id === state.selected);
    if (prev) prev.phase = 'idle';
  }

  state.selected = id;
  const shard = state.shards.find(s => s.id === id);
  if (shard) shard.phase = 'selected';
}

function trySortShard(binIndex) {
  if (state.selected === null) return;

  const shard = state.shards.find(s => s.id === state.selected);
  if (!shard) return;

  if (shard.shape.id !== state.bins[binIndex].shape.id) {
    haptic([8, 30, 8]);
    shard.shakeStart = performance.now();
    return;
  }

  // ✓ Correct sort
  haptic(12);
  shard.phase     = 'sorting';
  shard.sortStart = performance.now();
  state.selected  = null;

  setTimeout(() => {
    state.shards = state.shards.filter(s => s.id !== shard.id);
    state.bins[binIndex].count++;

    if (state.bins[binIndex].count >= BIN_CAPACITY) {
      onBinFilled(binIndex);
    }
    if (state.shards.length === 0) {
      setTimeout(spawnBlock, 350);
    }
  }, 230);
}

function onBinFilled(binIndex) {
  haptic([18, 10, 18]);
  state.bins[binIndex].count = 0;
  binFlashAt[binIndex] = performance.now();
  // binFillAnim stays near 1.0 and drains naturally toward 0

  state.gem.filled++;
  if (state.gem.filled >= GEM_FACETS) onGemComplete();
}

function onGemComplete() {
  haptic([25, 12, 25, 12, 40]);
  gemCompleteAt = performance.now();

  setTimeout(() => {
    state.gem.filled = 0;
    gemCompleteAt    = 0;
  }, 1800);
}

// ── Shard animation helper ────────────────────────────────────────────────
// Returns { x, y, scale, opacity } for the current frame
function shardAnim(shard, now) {
  if (shard.phase === 'flying') {
    const t = clamp01((now - shard.flyStart) / 450);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(PLAY_CX, shard.targetX, e),
      y:       lerp(PLAY_CY, shard.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (shard.phase === 'sorting') {
    const t = clamp01((now - shard.sortStart) / 220);
    return { x: shard.targetX, y: shard.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  if (shard.phase === 'dragging') {
    return { x: drag.x, y: drag.y, scale: 1.18, opacity: 1 };
  }

  if (shard.phase === 'snapping') {
    const t = clamp01((now - shard.snapStart) / 280);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(shard.snapFrom.x, shard.targetX, e),
      y:       lerp(shard.snapFrom.y, shard.targetY, e),
      scale:   lerp(1.18, 1, t),
      opacity: 1,
    };
  }

  // idle / selected – optional shake
  let shakeX = 0;
  if (shard.shakeStart) {
    const st = clamp01((now - shard.shakeStart) / 350);
    shakeX = Math.sin(st * Math.PI * 4.5) * 12 * (1 - st);
    if (st >= 1) shard.shakeStart = 0;
  }

  return { x: shard.targetX + shakeX, y: shard.targetY, scale: 1, opacity: 1 };
}

// ── Shape paths ───────────────────────────────────────────────────────────
function pathCircle(ctx, cx, cy, s) {
  ctx.arc(cx, cy, s * 0.42, 0, Math.PI * 2);
}

function pathHeart(ctx, cx, cy, s) {
  const r = s * 0.42;
  const x = cx, y = cy + r * 0.2;
  ctx.moveTo(x, y + r * 0.75);
  ctx.bezierCurveTo(x - r * 0.1, y + r * 0.4,  x - r, y + r * 0.1,  x - r, y - r * 0.3);
  ctx.bezierCurveTo(x - r, y - r,               x,     y - r * 0.65, x,     y - r * 0.1);
  ctx.bezierCurveTo(x,     y - r * 0.65,        x + r, y - r,        x + r, y - r * 0.3);
  ctx.bezierCurveTo(x + r, y + r * 0.1,         x + r * 0.1, y + r * 0.4, x, y + r * 0.75);
}

function pathStem(ctx, cx, cy, s) {
  const w = s * 0.22, h = s * 0.46;
  ctx.roundRect(cx - w, cy - h, w * 2, h * 2, w);
}

function pathLeaf(ctx, cx, cy, s) {
  const h = s * 0.46, w = s * 0.28;
  ctx.moveTo(cx, cy - h);
  ctx.bezierCurveTo(cx + w, cy - h * 0.3, cx + w, cy + h * 0.3, cx, cy + h);
  ctx.bezierCurveTo(cx - w, cy + h * 0.3, cx - w, cy - h * 0.3, cx, cy - h);
}

function drawShapePath(ctx, shape, cx, cy, size) {
  ctx.beginPath();
  switch (shape.id) {
    case 'circle': pathCircle(ctx, cx, cy, size); break;
    case 'heart':  pathHeart(ctx, cx, cy, size);  break;
    case 'stem':   pathStem(ctx, cx, cy, size);   break;
    case 'leaf':   pathLeaf(ctx, cx, cy, size);   break;
  }
  ctx.closePath();
}

// ── Hit testing ───────────────────────────────────────────────────────────

function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

let langBtnBounds = null; // set during drawHeader each frame

function hitTest(x, y, now) {
  // Lang button
  if (langBtnBounds) {
    const b = langBtnBounds;
    if (inRect(x, y, b.x, b.y, b.w, b.h)) return { type: 'lang' };
  }

  // Shards (reverse so topmost is checked first)
  if (state.phase === 'shards') {
    for (const shard of [...state.shards].reverse()) {
      if (shard.phase === 'sorting') continue;
      const a  = shardAnim(shard, now);
      const dx = x - a.x, dy = y - a.y;
      if (Math.sqrt(dx * dx + dy * dy) < SHARD_SIZE * 0.45 * a.scale) {
        return { type: 'shard', id: shard.id };
      }
    }
  }

  // Block
  if (state.phase === 'block') {
    const hw = BLOCK_SIZE / 2;
    if (inRect(x, y, PLAY_CX - hw, PLAY_CY - hw, BLOCK_SIZE, BLOCK_SIZE)) {
      return { type: 'block' };
    }
  }

  // Bins
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(x, y, bx, BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// ── Input ─────────────────────────────────────────────────────────────────
let lastTouchEnd = 0;

function initDrag(coords) {
  const now = performance.now();
  const hit = hitTest(coords.x, coords.y, now);
  if (!hit || hit.type !== 'shard') return;

  const shard = state.shards.find(s => s.id === hit.id);
  if (!shard || shard.phase === 'sorting') return;

  haptic(8);
  drag.active  = true;
  drag.shardId = hit.id;
  drag.x       = coords.x;
  drag.y       = coords.y;
  shard.phase  = 'dragging';
  state.selected = null;
}

function updateDrag(coords) {
  if (!drag.active) return;
  drag.x = coords.x;
  drag.y = coords.y;
}

function endDrag(coords) {
  if (!drag.active) return;
  drag.active = false;

  const shard = state.shards.find(s => s.id === drag.shardId);
  drag.shardId = null;
  if (!shard) return;

  // Check if dropped on a bin
  let binIndex = -1;
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(coords.x, coords.y, bx, BIN_Y, BIN_W, BIN_H)) { binIndex = i; break; }
  }

  if (binIndex >= 0) {
    state.selected = shard.id;
    trySortShard(binIndex);
    // trySortShard sets phase='sorting' on success – if still 'dragging', it failed
  }

  // Snap back if not successfully sorted
  if (shard.phase === 'dragging') {
    shard.snapFrom  = { x: drag.x, y: drag.y };
    shard.snapStart = performance.now();
    shard.phase     = 'snapping';
    state.selected  = null;
  }
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updateDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
}, { passive: false });

canvas.addEventListener('mousedown',  (e) => { initDrag(canvasCoords(e)); });
canvas.addEventListener('mousemove',  (e) => { updateDrag(canvasCoords(e)); });
canvas.addEventListener('mouseup',    (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'lang':  toggleLang(); break;
    case 'block': tapBlock();   break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('knack-lang', lang);
}

// ── Draw functions ────────────────────────────────────────────────────────
function drawHeader() {
  // Title
  ctx.fillStyle    = TEXT_HI;
  ctx.font         = 'bold 22px system-ui';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign    = 'left';
  ctx.fillText('knack!', 22, 46);

  // Lang button
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 6);
  ctx.stroke();

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawGem(now) {
  // Hexagon vertices – pointy-top orientation
  const verts = Array.from({ length: 6 }, (_, i) => {
    const a = (i * 60 - 90) * Math.PI / 180;
    return [GEM_CX + GEM_R * Math.cos(a), GEM_CY + GEM_R * Math.sin(a)];
  });

  const isComplete = gemCompleteAt > 0 && now - gemCompleteAt < 1800;
  const flash      = isComplete ? Math.sin(clamp01((now - gemCompleteAt) / 1800) * Math.PI) : 0;

  if (flash > 0) { ctx.shadowColor = '#fff'; ctx.shadowBlur = 28 * flash; }

  // Draw 6 facets
  for (let i = 0; i < GEM_FACETS; i++) {
    const target  = isComplete ? 0.85 : (i < state.gem.filled ? 0.85 : 0.1);
    facetAnim[i] += (target - facetAnim[i]) * 0.08;

    ctx.globalAlpha = facetAnim[i];
    ctx.fillStyle   = FACET_COLORS[i];
    ctx.beginPath();
    ctx.moveTo(GEM_CX, GEM_CY);
    ctx.lineTo(verts[i][0], verts[i][1]);
    ctx.lineTo(verts[(i + 1) % 6][0], verts[(i + 1) % 6][1]);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur  = 0;

  // Hexagon outline
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  verts.forEach(([x, y], i) => i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y));
  ctx.closePath();
  ctx.stroke();

  // Label
  ctx.fillStyle    = TEXT_DIM;
  ctx.font         = '11px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(
    isComplete ? t('gem_done') : t('gem_label', state.gem.filled, GEM_FACETS),
    GEM_CX, GEM_CY + GEM_R + 20
  );
  ctx.textAlign = 'left';
}

function drawBlock(now) {
  if (state.phase !== 'block' || !state.block) return;

  const block = state.block;

  // Enter animation
  const enterT  = clamp01((now - blockEnterStart) / 300);
  const enterSc = easeOutBack(enterT);

  // Tap wobble: quick outward punch, then settle
  const wobbleAge = block.lastTapAt > 0 ? now - block.lastTapAt : Infinity;
  const wobbleSc  = wobbleAge < 200 ? 1 + Math.sin(clamp01(wobbleAge / 200) * Math.PI) * 0.08 : 1;

  const sc = enterSc * wobbleSc;
  const hw = BLOCK_SIZE / 2 * sc;
  const r  = BLOCK_R * sc;

  ctx.shadowColor = block.color.hex;
  ctx.shadowBlur  = 24;
  ctx.fillStyle   = block.color.hex;
  ctx.beginPath();
  ctx.roundRect(PLAY_CX - hw, PLAY_CY - hw, hw * 2, hw * 2, r);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Cracks – clipped to block shape
  if (block.cracks.length > 0) {
    const progress = 1 - block.tapsLeft / block.tapsRequired;
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(PLAY_CX - hw, PLAY_CY - hw, hw * 2, hw * 2, r);
    ctx.clip();

    ctx.strokeStyle = 'rgba(0, 0, 0, 0.28)';
    ctx.lineWidth   = 1.2;
    ctx.lineCap     = 'round';
    for (const c of block.cracks) {
      ctx.beginPath();
      ctx.moveTo(PLAY_CX + c.x1 * sc, PLAY_CY + c.y1 * sc);
      ctx.lineTo(PLAY_CX + c.x2 * sc, PLAY_CY + c.y2 * sc);
      ctx.stroke();
    }
    ctx.restore();
  }
}

function drawShards(now, dragOnly = false) {
  for (const shard of state.shards) {
    const isDragged = shard.phase === 'dragging';
    if (dragOnly !== isDragged) continue;
    const a = shardAnim(shard, now);
    if (a.opacity < 0.01) continue;

    ctx.globalAlpha = a.opacity;
    if (shard.phase === 'selected' || shard.phase === 'dragging' || shard.phase === 'snapping') {
      ctx.shadowColor = shard.color.hex;
      ctx.shadowBlur  = shard.phase === 'dragging' ? 22 : 14;
    }

    ctx.fillStyle = shard.color.hex;
    drawShapePath(ctx, shard.shape, a.x, a.y, SHARD_SIZE * a.scale);
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 4; i++) {
    const bin = state.bins[i];
    const bx  = BIN_LEFT + i * (BIN_W + BIN_GAP);
    const by  = BIN_Y;

    // Animate fill level
    const fillTarget = bin.count / BIN_CAPACITY;
    binFillAnim[i]  += (fillTarget - binFillAnim[i]) * 0.15;

    // Flash factor (0–1) after bin fills
    const flashAge = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash    = flashAge < 600 ? 1 - flashAge / 600 : 0;

    // Background
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.fill();

    // Fill bar – clipped to bin shape
    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.2 + flash * 0.45;
      ctx.fillStyle   = TEXT_HI;
      const fillH = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Border
    if (flash > 0) { ctx.shadowColor = TEXT_HI; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = flash > 0 ? TEXT_HI : BORDER;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // Shape icon
    ctx.globalAlpha = 0.3 + flash * 0.5;
    ctx.fillStyle   = TEXT_HI;
    drawShapePath(ctx, bin.shape, bx + BIN_W / 2, by + BIN_H / 2, 30);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ── Game loop ─────────────────────────────────────────────────────────────
function draw(now) {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  drawHeader();
  drawGem(now);
  drawBlock(now);
  drawShards(now, false);
  drawBins(now);
  drawShards(now, true);

  requestAnimationFrame(draw);
}

// ── Boot ──────────────────────────────────────────────────────────────────
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

spawnBlock();
requestAnimationFrame(draw);
</script>

</body>
</html>

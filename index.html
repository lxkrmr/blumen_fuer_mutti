<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blumen fÃ¼r Mutti</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Bâ™¥M">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
      touch-action: none;
    }

    /* On actual phone: no frame */
    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script type="module">
import {
  createConfig, createState,
  applyAction as engineApply,
  tick        as engineTick,
  getEffects, shapeToColor,
} from './engine.js';

// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// â”€â”€ i18n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STRINGS = {
  de: {
    lang_toggle:        'EN',
    building_one:       'Harry baut 1 Blume â€¦',
    building_many:      (n) => `Harry baut ${n} Blumen â€¦`,
    building_idle_main: 'teile sortieren um blumen zu erschaffen',
    mutti_selling:      'Mutti verkauft â€¦',
    shop_title:         'Shop',
    shop_back:          'â† ZurÃ¼ck',
    shop_buy:           'Kaufen',
    shop_owned:         'Gekauft âœ“',
    shop_locked:        '???',
    shop_cant_afford:   'Zu wenig MÃ¼nzen',
    shop_reset_name:    'Spiel den selben Song nochmal',
    shop_reset_desc:    'Die Cantina Band spielt immer weiter. Du auch.',
    shop_reset_confirm: 'Du willst wirklich das Spiel neu starten?',
    intro_skip:         'Ãœberspringen',
    actor_player:       'Du',
    actor_harry:        'Harry',
    actor_mutti:        'Mutti',
  },
  en: {
    lang_toggle:        'DE',
    building_one:       'Harry is building 1 flower â€¦',
    building_many:      (n) => `Harry is building ${n} flowers â€¦`,
    building_idle_main: 'sort parts to grow flowers',
    mutti_selling:      'Mutti is selling â€¦',
    shop_title:         'Shop',
    shop_back:          'â† Back',
    shop_buy:           'Buy',
    shop_owned:         'Owned âœ“',
    shop_locked:        '???',
    shop_cant_afford:   'Not enough coins',
    shop_reset_name:    'Play the Same Song',
    shop_reset_desc:    'The Cantina Band never stops. Neither do you.',
    shop_reset_confirm: 'You really want to restart the game?',
    intro_skip:         'Skip',
    actor_player:       'You',
    actor_harry:        'Harry',
    actor_mutti:        'Mutti',
  },
};

// Intro slide texts â€“ one line per slide, Harry voice, Bruno format.
const INTRO_SLIDES = {
  de: [
    'Ihr seid also zusammen. Harry beobachtet das.',
    'Andauernd: â€Wenn wir auf der Alpaka-Farm leben â€¦" Wo Alpaka-Farm? Wo?',
    'Jemand muss handeln. Ich bin dieser Jemand.',
    'Die Blumen. Ihr habt euch gefreut. Das ist die Idee.',
    'Du sortierst. Ich baue. Mutti verkauft. FamiliengeschÃ¤ft.',
    'Hier ist dein erstes Pack. Von mir. Alle Teile fÃ¼r eine Blume.',
  ],
  en: [
    'So you\'re together. Harry is watching.',
    'Always: "When we live on the alpaca farm â€¦" Where alpaca farm? Where?',
    'Someone must act. I am that someone.',
    'The flowers. You were both so happy. That\'s the idea.',
    'You sort. I build. Mutti sells. Family business.',
    'Here is your first pack. From me. Every part for one flower.',
  ],
};

let lang = localStorage.getItem('bfm-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// â”€â”€ Upgrade tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Linear skill tree: buy in order. All passive + permanent.
// Effect functions mutate the fx object â€“ later upgrades can build on earlier ones.
// The engine ignores name/desc; they are used only by the renderer.
const UPGRADE_TREE = [
  {
    id: 'schere', actor: 'player', cost: 15,
    name: { de: 'Schere',               en: 'Scissors' },
    desc: { de: 'Eine Schere! TÃ¼ten Ã¶ffnen sich mit einem einzigen Schnitt.',
            en: 'Scissors! Packs open with a single cut.' },
    effect: fx => { fx.bagTaps = 1; },
  },
  {
    id: 'gummiDaumen', actor: 'harry', cost: 40,
    name: { de: 'Gummi-Daumen',         en: 'Rubber Thumbs' },
    desc: { de: 'Katzen beherrschen die Welt nicht, weil sie keine Daumen haben. Problem gelÃ¶st.',
            en: "Cats don't rule the world only because they lack thumbs. Problem solved." },
    effect: fx => { fx.buildBaseMs = 12000; },
  },
  {
    id: 'grosshaendler', actor: 'mutti', cost: 80,
    name: { de: 'GroÃŸhÃ¤ndler',           en: 'Wholesaler' },
    desc: { de: 'Ein GroÃŸhÃ¤ndler hat euch entdeckt. Harry ist nervÃ¶s bei VertrÃ¤gen.',
            en: 'A wholesaler noticed you. Harry is nervous around contracts.' },
    effect: fx => { fx.bagShards = 5; },
  },
  {
    id: 'staubsauger', actor: 'player', cost: 150,
    name: { de: 'Staubsauger',           en: 'Vacuum' },
    desc: { de: 'Die Bins saugen Teile in der NÃ¤he an. Nicht alles â€“ aber nah dran.',
            en: 'Bins attract nearby parts. Not everything â€“ but close.' },
    effect: fx => { fx.staubsauger = true; },
  },
  {
    id: 'harryTikTok', actor: 'harry', cost: 300,
    name: { de: 'Harry goes TikTok',    en: 'Harry goes TikTok' },
    desc: { de: 'Harry hat einen Account. 1k Follower. Die Kommentare fragen nach seinem Supplement-Stack. Er hat keinen.',
            en: 'Harry has an account. 1k followers. Comments ask about his supplement stack. He has none.' },
    effect: fx => { fx.coinValue = Math.round(fx.coinValue * 1.8); },
  },
  {
    id: 'bobbyTuning', actor: 'mutti', cost: 500,
    name: { de: 'Bobby-Tuning',          en: 'Bobby Tuning' },
    desc: { de: 'Heck-Spoiler und Rallye-Streifen. Die Streifen machen ihn schneller. Alle wissen das.',
            en: 'Rear spoiler and rally stripes. The stripes make it faster. Everyone knows this.' },
    effect: fx => { fx.sellBaseMs = 4000; },
  },
  {
    id: 'dinoSparschwein', actor: 'player', cost: 800,
    name: { de: 'Dino-Sparschwein',      en: 'Dino Piggy Bank' },
    desc: { de: 'Horizontal rotierendes Dino-Sparschwein. Es dreht sich. Die Zinsen sind absurd. Brainrot.',
            en: 'Horizontally rotating dino piggy bank. It spins. The interest is absurd. Brainrot.' },
    effect: fx => { fx.dinoSparschwein = true; },
  },
  {
    id: 'harryLabel', actor: 'harry', cost: 1500,
    name: { de: "Harry's eigenes Label", en: "Harry's Own Label" },
    desc: { de: 'Wer braucht einen Brand Deal wenn man selbst die Brand ist.',
            en: 'Who needs a brand deal when you are the brand.' },
    effect: fx => { fx.coinValue = Math.round(fx.coinValue * 2.0); },
  },
  {
    id: 'bobbyZuwachs', actor: 'mutti', cost: 2500,
    name: { de: 'Bobby-Zuwachs',         en: "Bobby's Companion" },
    desc: { de: 'Ein zweites Fahrzeug. Berge â†’ Unimog. Meer â†’ Speedboat. Maximale Liefergeschwindigkeit.',
            en: 'A second vehicle. Mountains â†’ Unimog. Sea â†’ Speedboat. Maximum delivery speed.' },
    effect: fx => { fx.sellBaseMs = 2000; },
  },
];

// â”€â”€ Engine config + state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pass the shell's UPGRADE_TREE (with name/desc) to the engine config.
// The engine only reads id, cost, and effect from each entry.
const config = createConfig({ UPGRADE_TREE });
let S;   // engine GameState â€“ set in boot, mutated by dispatch() and the game loop

// â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// â”€â”€ Actor colors (player / Harry / Mutti) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ACTOR_COLOR = { player: '#58a6ff', harry: '#f48fb1', mutti: '#e3b341' };

// â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HEADER_H    = 50;
const INDICATOR_R = 80;
const INDICATOR_CX = W / 2;                                      // 215
const INDICATOR_CY = HEADER_H + INDICATOR_R + 10;                // 140
const BIN_H     = 96,  BIN_W = 80, BIN_GAP = 12, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;                               // 800
const BIN_TOTAL = 4 * BIN_W + 3 * BIN_GAP;                      // 356
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                          // 37
const PLAY_Y    = INDICATOR_CY + INDICATOR_R + 32;               // 252
const PLAY_H    = BIN_Y - PLAY_Y - 20;                          // 528
const PLAY_CX   = W / 2;                                        // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                          // ~516

const INDICATOR_OUTER_R = 88;   // inner=80 Harry, outer=88 Mutti (8px gap)

// Spawn zones for pieces flying out of pack (relative to PLAY_CX/CY)
const PIECE_ZONES = [
  { dx: -105, dy: -120 }, { dx:   0, dy: -130 }, { dx: 105, dy: -120 },
  { dx: -120, dy:  -40 }, { dx:   0, dy:  -30 }, { dx: 120, dy:  -40 },
  { dx: -110, dy:   50 }, { dx:   0, dy:   55 }, { dx: 110, dy:   50 },
  { dx:  -80, dy:  130 }, { dx:  30, dy:  125 }, { dx:  80, dy:  130 },
];

const PIECE_SIZE = 60;
const BAG_PX     = 90;   // visual bag size in px

// â”€â”€ Visual shell state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These track rendering/animation details that the engine does not need to know about.

// Pieces currently in the play area (flying/idle/dragging/sorting).
// Synced from engine events: added on pack_opened, removed 230ms after piece_sorted.
let pieces = [];   // { id, shape, color: { hex }, targetX, targetY, flyStart, phase, sortStart, shakeStart }

// Pack visual state â€“ purely cosmetic, not tracked by engine.
const packVisual = { lastTapAt: 0, angle: 0 };

// Real-time start timestamps for smooth arc animation in the indicator.
// Updated by handleEvents when build_started / sell_started events fire.
let buildTimerRealStart = 0;
let sellTimerRealStart  = 0;

// Timestamp when the pack enter animation started.
// Set in the future (+ delay ms) to create a visual gap after piece sorting.
let packEnterStart = 0;

// rAF timestamp of the previous frame â€“ used to compute delta for engineTick.
let lastFrameTime = 0;

// Bin fill animations (0â†’1 lerp toward fill level, clamps at 1)
const binFillAnim = Array(4).fill(0);
// Timestamp of last recipe-threshold event per bin (for flash animation)
const binFlashAt  = Array(4).fill(0);

// â”€â”€ UI state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentScreen = 'main';   // 'main' | 'shop' | 'intro'

let introSlide      = 0;
let introSkipBounds = null;

let langBtnBounds   = null;
let shopBtnBounds   = null;
let shopBackBounds  = null;
let shopBuyBtns     = [];
let shopResetBounds = null;

// â”€â”€ Drag state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const drag = {
  active:  false,
  pieceId: null,
  x:       0,
  y:       0,
};

// â”€â”€ dispatch + handleEvents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// dispatch() is the single entry point for all player actions and system triggers.
// It calls the pure engine, then reacts to returned events with side effects.
function dispatch(action) {
  const { state: newS, events } = engineApply(S, config, action, Math.random);
  S = newS;
  handleEvents(events);
}

function handleEvents(events) {
  for (const ev of events) {
    switch (ev.type) {

      case 'pack_tapped': {
        packVisual.lastTapAt = performance.now();
        packVisual.angle    += (Math.random() - 0.5) * 0.25;
        // Haptic: last tap (open) or mid-tap
        if (ev.tapsLeft <= 0) haptic([10, 20, 10]);
        else                  haptic(8);
        break;
      }

      case 'pack_opened': {
        // Create visual entries for each piece flying into the play area
        const now   = performance.now();
        const zones = [...PIECE_ZONES].sort(() => Math.random() - 0.5);
        pieces = ev.pieces.map((p, i) => ({
          id:         p.id,
          shape:      p.shape,
          color:      { hex: p.color },
          targetX:    PLAY_CX + jitter(zones[i % zones.length].dx),
          targetY:    PLAY_CY + jitter(zones[i % zones.length].dy),
          flyStart:   now,
          phase:      'flying',
          sortStart:  0,
          shakeStart: 0,
        }));
        break;
      }

      case 'pack_spawned': {
        // Reset pack visual state for the new bag.
        // If spawned after a sort, delay the enter animation so piece sorting can finish.
        packVisual.angle    = 0;
        packVisual.lastTapAt = 0;
        const delay = ev.fromSort ? 350 : 0;
        packEnterStart = performance.now() + delay;
        break;
      }

      case 'piece_sorted': {
        const vp = pieces.find(p => p.id === ev.pieceId);
        if (vp) {
          // Anchor at current drag position before starting sort-out animation
          vp.targetX   = drag.x;
          vp.targetY   = drag.y;
          vp.phase     = 'sorting';
          vp.sortStart = performance.now();
          setTimeout(() => {
            pieces = pieces.filter(p => p.id !== ev.pieceId);
          }, 230);
        }
        haptic(12);
        saveState();
        break;
      }

      case 'bin_threshold': {
        binFlashAt[ev.binIndex] = performance.now();
        haptic([18, 10, 18]);
        break;
      }

      case 'piece_wrong_bin': {
        const vp = pieces.find(p => p.id === ev.pieceId);
        if (vp) {
          vp.targetX    = drag.x;
          vp.targetY    = drag.y;
          vp.phase      = 'idle';
          vp.shakeStart = performance.now();
        }
        haptic([8, 30, 8]);
        break;
      }

      case 'build_started': {
        buildTimerRealStart = performance.now();
        break;
      }

      case 'build_complete': {
        haptic([20, 12, 35]);
        break;
      }

      case 'sell_started': {
        sellTimerRealStart = performance.now();
        break;
      }

      case 'sell_complete': {
        haptic([15, 10, 30]);
        saveState();
        break;
      }

      case 'upgrade_bought': {
        haptic([20, 10, 20, 10, 30]);
        saveState();
        break;
      }

      case 'sparschwein_payout': {
        haptic([30, 15, 30, 15, 50]);
        break;
      }
    }
  }
}

// â”€â”€ Easing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}

function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

function formatCoins(n) {
  return n.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US');
}

// â”€â”€ Canvas helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fillRRect(x, y, w, h, r)   { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.fill();   }
function strokeRRect(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.stroke(); }

// Splits text into lines that fit within maxWidth (used for upgrade descriptions).
function wrapText(text, maxWidth) {
  const words = text.split(' ');
  const lines = [];
  let   line  = '';
  for (const word of words) {
    const test = line ? `${line} ${word}` : word;
    if (ctx.measureText(test).width > maxWidth && line) {
      lines.push(line);
      line = word;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);
  return lines;
}

// â”€â”€ Haptics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// â”€â”€ Layout helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const binX  = i => BIN_LEFT + i * (BIN_W + BIN_GAP);   // left edge of bin i
const binCX = i => binX(i) + BIN_W / 2;                // center x of bin i
const binCY = ()  => BIN_Y  + BIN_H / 2;               // center y (all bins same)

// â”€â”€ Update loop â€“ visual only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Engine state is mutated in the game loop via engineTick + dispatch.
// This function handles purely visual transitions that run every frame.
function update(now) {
  // Piece phase transitions (flying â†’ idle after 450ms)
  for (const piece of pieces) {
    if (piece.phase === 'flying' && clamp01((now - piece.flyStart) / 450) >= 1) {
      piece.phase = 'idle';
    }
    if (piece.shakeStart && clamp01((now - piece.shakeStart) / 350) >= 1) {
      piece.shakeStart = 0;
    }
  }

  // Bin fill animation â€“ lerps toward fill target (clamps at 1 once full)
  for (let i = 0; i < 4; i++) {
    const recipe     = config.FLOWER_RECIPE[S.bins[i].shape.id];
    const fillTarget = Math.min(S.bins[i].pieces.length / recipe, 1);
    binFillAnim[i]  += (fillTarget - binFillAnim[i]) * 0.15;
  }
}

// â”€â”€ Piece animation helper (pure) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns { x, y, scale, opacity } for the current frame. Read-only.
function pieceAnim(piece, now) {
  if (piece.phase === 'flying') {
    const t = clamp01((now - piece.flyStart) / 450);
    const e = easeOutBack(t);
    return {
      x:       lerp(PLAY_CX, piece.targetX, e),
      y:       lerp(PLAY_CY, piece.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (piece.phase === 'sorting') {
    const t = clamp01((now - piece.sortStart) / 220);
    return { x: piece.targetX, y: piece.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  if (piece.phase === 'dragging') {
    return { x: drag.x, y: drag.y, scale: 1.18, opacity: 1 };
  }

  // idle â€“ optional shake
  const shakeX = piece.shakeStart
    ? Math.sin(clamp01((now - piece.shakeStart) / 350) * Math.PI * 4.5)
      * 12 * (1 - clamp01((now - piece.shakeStart) / 350))
    : 0;

  return { x: piece.targetX + shakeX, y: piece.targetY, scale: 1, opacity: 1 };
}

// â”€â”€ Shape paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pathCircle(cx, cy, s) {
  ctx.arc(cx, cy, s * 0.42, 0, Math.PI * 2);
}

function pathHeart(cx, cy, s) {
  const r = s * 0.42;
  const x = cx, y = cy + r * 0.2;
  ctx.moveTo(x, y + r * 0.75);
  ctx.bezierCurveTo(x - r * 0.1, y + r * 0.4,  x - r, y + r * 0.1,  x - r, y - r * 0.3);
  ctx.bezierCurveTo(x - r, y - r,               x,     y - r * 0.65, x,     y - r * 0.1);
  ctx.bezierCurveTo(x,     y - r * 0.65,        x + r, y - r,        x + r, y - r * 0.3);
  ctx.bezierCurveTo(x + r, y + r * 0.1,         x + r * 0.1, y + r * 0.4, x, y + r * 0.75);
}

function pathStem(cx, cy, s) {
  const w = s * 0.22, h = s * 0.46;
  ctx.roundRect(cx - w, cy - h, w * 2, h * 2, w);
}

function pathLeaf(cx, cy, s) {
  const h = s * 0.46, w = s * 0.28;
  ctx.moveTo(cx - h, cy);
  ctx.bezierCurveTo(cx - h * 0.3, cy - w, cx + h * 0.3, cy - w, cx + h, cy);
  ctx.bezierCurveTo(cx + h * 0.3, cy + w, cx - h * 0.3, cy + w, cx - h, cy);
}

function drawShapePath(shape, cx, cy, size) {
  ctx.beginPath();
  switch (shape.id) {
    case 'circle': pathCircle(cx, cy, size); break;
    case 'heart':  pathHeart(cx, cy, size);  break;
    case 'stem':   pathStem(cx, cy, size);   break;
    case 'leaf':   pathLeaf(cx, cy, size);   break;
  }
  ctx.closePath();
}

// â”€â”€ Hit testing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

function hitTest(x, y, now) {
  // Intro screen â€“ skip button or tap anywhere to advance
  if (currentScreen === 'intro') {
    if (introSkipBounds && inRect(x, y, introSkipBounds.x, introSkipBounds.y, introSkipBounds.w, introSkipBounds.h)) {
      return { type: 'intro_skip' };
    }
    return { type: 'intro_next' };
  }

  // Lang button
  if (langBtnBounds && inRect(x, y, langBtnBounds.x, langBtnBounds.y, langBtnBounds.w, langBtnBounds.h)) {
    return { type: 'lang' };
  }

  // Shop reset item (bottom of shop)
  if (shopResetBounds && inRect(x, y, shopResetBounds.x, shopResetBounds.y, shopResetBounds.w, shopResetBounds.h)) {
    return { type: 'shop_reset' };
  }

  // Shop button (main screen)
  if (shopBtnBounds && inRect(x, y, shopBtnBounds.x, shopBtnBounds.y, shopBtnBounds.w, shopBtnBounds.h)) {
    return { type: 'shop_open' };
  }

  // Shop back button
  if (shopBackBounds && inRect(x, y, shopBackBounds.x, shopBackBounds.y, shopBackBounds.w, shopBackBounds.h)) {
    return { type: 'shop_back' };
  }

  // Shop buy buttons
  for (const btn of shopBuyBtns) {
    if (inRect(x, y, btn.x, btn.y, btn.w, btn.h)) {
      return { type: 'shop_buy', id: btn.id };
    }
  }

  // Game screen only â€“ skip piece/pack/bin interactions when in shop
  if (currentScreen !== 'main') return null;

  // Pieces (reverse so topmost is checked first)
  if (S.phase === 'pieces') {
    for (const piece of [...pieces].reverse()) {
      if (piece.phase === 'sorting') continue;
      const a  = pieceAnim(piece, now);
      const dx = x - a.x, dy = y - a.y;
      if (Math.sqrt(dx * dx + dy * dy) < PIECE_SIZE * 0.45 * a.scale) {
        return { type: 'piece', id: piece.id };
      }
    }
  }

  // Pack
  if (S.phase === 'pack') {
    const bw = BAG_PX * 0.72;
    const bh = BAG_PX * 1.05;
    if (inRect(x, y, PLAY_CX - bw / 2, PLAY_CY - bh / 2, bw, bh)) {
      return { type: 'pack' };
    }
  }

  // Bins
  for (let i = 0; i < 4; i++) {
    if (inRect(x, y, binX(i), BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTouchEnd = 0;

function initDrag(coords) {
  if (currentScreen !== 'main') return;
  const now = performance.now();
  const hit = hitTest(coords.x, coords.y, now);
  if (!hit || hit.type !== 'piece') return;

  const piece = pieces.find(p => p.id === hit.id);
  if (!piece || piece.phase === 'sorting') return;

  haptic(8);
  drag.active  = true;
  drag.pieceId = hit.id;
  drag.x       = coords.x;
  drag.y       = coords.y;
  piece.phase  = 'dragging';
}

function updateDrag(coords) {
  if (!drag.active) return;
  drag.x = coords.x;
  drag.y = coords.y;
}

function endDrag(coords) {
  if (!drag.active) return;
  drag.active = false;
  // Update drag position to the final drop coordinates so handleEvents can read them.
  drag.x = coords.x;
  drag.y = coords.y;

  const piece = pieces.find(p => p.id === drag.pieceId);
  drag.pieceId = null;
  if (!piece) return;

  // Check if dropped directly on a bin
  let binIndex = -1;
  for (let i = 0; i < 4; i++) {
    if (inRect(coords.x, coords.y, binX(i), BIN_Y, BIN_W, BIN_H)) { binIndex = i; break; }
  }

  if (binIndex >= 0) {
    dispatch({ type: 'sort_piece', pieceId: piece.id, binIndex });
    return;
  }

  // Staubsauger: auto-sort if dropped near a matching bin
  if (getEffects(config, S.upgrades.purchased).staubsauger) {
    const VACUUM_R = 80;
    for (let i = 0; i < 4; i++) {
      if (Math.hypot(coords.x - binCX(i), coords.y - binCY()) < VACUUM_R
          && piece.shape.id === S.bins[i].shape.id) {
        dispatch({ type: 'sort_piece', pieceId: piece.id, binIndex: i });
        return;
      }
    }
  }

  // Dropped on empty space â€“ place freely at drop position
  piece.targetX  = coords.x;
  piece.targetY  = coords.y;
  piece.phase    = 'idle';
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updateDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
}, { passive: false });

canvas.addEventListener('mousedown',  (e) => { initDrag(canvasCoords(e)); });
canvas.addEventListener('mousemove',  (e) => { updateDrag(canvasCoords(e)); });
canvas.addEventListener('mouseup',    (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'intro_next':
      if (introSlide < INTRO_SLIDES.de.length - 1) { introSlide++; }
      else                                          { finishIntro(); }
      break;
    case 'intro_skip':  finishIntro();                            break;
    case 'lang':        toggleLang();                             break;
    case 'pack':        dispatch({ type: 'tap_pack' });           break;
    case 'shop_open':   currentScreen = 'shop';                  break;
    case 'shop_back':   currentScreen = 'main';
                        shopBackBounds  = null;
                        shopBuyBtns     = [];
                        shopResetBounds = null;                   break;
    case 'shop_reset':  localStorage.clear(); location.reload(); break;
    case 'shop_buy':    dispatch({ type: 'buy_upgrade', id: hit.id }); break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('bfm-lang', lang);
}

function finishIntro() {
  introSlide    = 0;
  currentScreen = 'main';
  dispatch({ type: 'spawn_harry_pack' });
}

// â”€â”€ Flower draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFlower(cx, cy, rotation, scale, parts) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  ctx.scale(scale, scale);
  ctx.translate(0, -58); // origin = bottom of stem

  const circleColor = parts.circle && parts.circle[0] ? parts.circle[0].color : '#fff176';
  const heartColors = parts.heart || [];
  const stemColors  = parts.stem  || [];
  const leafColors  = parts.leaf  || [];
  const hc = i => heartColors[i] ? heartColors[i].color : '#f48fb1';
  const sc = i => stemColors[i]  ? stemColors[i].color  : '#52b788';
  const lc = i => leafColors[i]  ? leafColors[i].color  : '#1e4d2b';

  // Right leaf behind stem â€“ outer tip points upper-right
  ctx.save();
  ctx.translate(10, 44);
  ctx.rotate(-0.8);
  ctx.fillStyle = lc(1);
  ctx.beginPath(); pathLeaf(0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // Stem (3 segments as stroked lines â€“ guaranteed connected, per-segment color)
  const kinks = [ {x:2,y:15}, {x:7,y:30}, {x:0,y:45}, {x:3,y:58} ];
  ctx.lineWidth = 5;
  ctx.lineCap   = 'round';
  ctx.lineJoin  = 'round';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.strokeStyle = sc(i);
    ctx.moveTo(kinks[i].x,   kinks[i].y);
    ctx.lineTo(kinks[i+1].x, kinks[i+1].y);
    ctx.stroke();
  }
  ctx.lineCap  = 'butt';
  ctx.lineJoin = 'miter';

  // Left leaf in front of stem â€“ outer tip points upper-left
  ctx.save();
  ctx.translate(-8, 30);
  ctx.rotate(0.8);
  ctx.fillStyle = lc(0);
  ctx.beginPath(); pathLeaf(0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // Petal base â€“ solid circle to block bleed-through from behind
  ctx.fillStyle = hc(0);
  ctx.beginPath(); pathCircle(0, 0, 27); ctx.fill();

  // Petals: 8 hearts in a ring, tips toward center
  const PETAL_R    = 17;
  const PETAL_SIZE = 20;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    ctx.save();
    ctx.translate(Math.cos(angle) * PETAL_R, Math.sin(angle) * PETAL_R);
    ctx.rotate(angle + Math.PI / 2);
    ctx.fillStyle = hc(i);
    ctx.beginPath(); pathHeart(0, 0, PETAL_SIZE); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // Center circle
  ctx.fillStyle = circleColor;
  ctx.beginPath(); pathCircle(0, 0, 14); ctx.fill();

  ctx.restore();
}

// â”€â”€ Draw functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Draws the flower stock (Lager) inside the Harry indicator
function drawStock(cx, cy) {
  const n = S.stock.length;
  if (n === 0) return;

  const FAN_RAD    = 70 * Math.PI / 180;  // Â±35Â° total spread
  const MAX_VISUAL = 7;
  const visible    = Math.min(n, MAX_VISUAL);

  for (let i = 0; i < visible; i++) {
    const t        = visible === 1 ? 0 : (i / (visible - 1) - 0.5);
    const rotation = t * FAN_RAD;
    drawFlower(cx, cy, rotation, 1.0, S.stock[i].parts);
  }
}

function drawHarryIndicator(now) {
  const cx = INDICATOR_CX, cy = INDICATOR_CY;
  const r  = INDICATOR_R;
  const ro = INDICATOR_OUTER_R;

  // Harry arc progress from real-time start + duration from engine
  const harryActive   = S.buildTimer.active || S.buildQueue.length > 0;
  const harryProgress = S.buildTimer.active
    ? clamp01((now - buildTimerRealStart) / S.buildTimer.durationMs)
    : 0;
  const harryPulse = harryActive ? 0.6 + 0.4 * Math.sin(now / 700) : 0;

  // Mutti arc progress from real-time start + duration from engine
  const muttiActive   = S.sellTimer.active || S.stock.length > 0;
  const muttiProgress = S.sellTimer.active
    ? clamp01((now - sellTimerRealStart) / S.sellTimer.durationMs)
    : 0;
  const muttiPulse = S.sellTimer.active ? 0.6 + 0.4 * Math.sin(now / 500) : 0;

  // Flower stock (Lager) inside circle
  drawStock(cx, cy + 38);

  // Circle background
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = harryActive ? `rgba(13,17,23,${0.55 + harryPulse * 0.05})` : 'rgba(13,17,23,0.55)';
  ctx.fill();

  // Harry: inner track ring
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 3;
  ctx.stroke();

  // Harry: blue build arc
  if (harryActive) {
    ctx.shadowColor = '#58a6ff';
    ctx.shadowBlur  = 10 + 8 * harryPulse;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + harryProgress * Math.PI * 2);
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth   = 3;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Mutti: outer track ring â€“ always visible so the layout never jumps
  ctx.beginPath();
  ctx.arc(cx, cy, ro, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(227,179,65,0.15)';
  ctx.lineWidth   = 2.5;
  ctx.stroke();

  // Mutti: gold sell arc (only when she's actively selling)
  if (S.sellTimer.active) {
    ctx.shadowColor = '#e3b341';
    ctx.shadowBlur  = 10 + 8 * muttiPulse;
    ctx.beginPath();
    ctx.arc(cx, cy, ro, -Math.PI / 2, -Math.PI / 2 + muttiProgress * Math.PI * 2);
    ctx.strokeStyle = '#e3b341';
    ctx.lineWidth   = 2.5;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Center dot when completely idle and empty
  if (S.stock.length === 0 && S.coins === 0 && !harryActive) {
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(110,118,129,0.3)';
    ctx.fill();
  }

  // Coin badge â€“ pill at the bottom of the outer ring
  if (S.coins > 0) {
    const badgeY = cy + ro;
    const ph = 22, pad = 12;
    ctx.font = '12px system-ui';
    const coinLabel = `ğŸ’° ${formatCoins(S.coins)}`;
    const tw = ctx.measureText(coinLabel).width;
    const pw = tw + pad * 2;
    const px = cx - pw / 2, py = badgeY - ph / 2;

    ctx.fillStyle = BG;
    fillRRect(px, py, pw, ph, ph / 2);
    ctx.strokeStyle = BORDER; ctx.lineWidth = 1;
    strokeRRect(px, py, pw, ph, ph / 2);

    ctx.fillStyle    = '#e3b341';
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'center';
    ctx.fillText(coinLabel, cx, badgeY);
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
  }

  // Labels below
  const labelBaseY = cy + ro + 30;
  ctx.font      = '11px system-ui';
  ctx.textAlign = 'center';

  let harryLabel;
  if (S.buildQueue.length > 1)      harryLabel = t('building_many', S.buildQueue.length);
  else if (S.buildQueue.length === 1) harryLabel = t('building_one');
  else                               harryLabel = t('building_idle_main');

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(harryLabel, cx, labelBaseY);

  if (S.sellTimer.active || S.stock.length > 0) {
    ctx.fillStyle = '#e3b341';
    ctx.fillText(t('mutti_selling'), cx, labelBaseY + 16);
  }

  ctx.textAlign = 'left';
}

function drawHeader() {
  // Bâ™¥M logo left
  ctx.font         = 'bold 18px system-ui';
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillStyle    = '#f48fb1';
  ctx.fillText('B', 22, HEADER_H / 2);
  const bw = ctx.measureText('B').width;
  ctx.fillStyle = '#f06292';
  ctx.fillText('â™¥', 22 + bw, HEADER_H / 2);
  const hw = ctx.measureText('â™¥').width;
  ctx.fillStyle = TEXT_HI;
  ctx.fillText('M', 22 + bw + hw, HEADER_H / 2);

  // Pack + flower counters â€“ center of header
  ctx.font = '11px system-ui';
  const miniH       = 11;
  const iconGap     = 4;
  const groupGap    = 12;
  const miniPackW   = Math.round(miniH * 0.72);
  const packNumW    = ctx.measureText(` ${S.packsOpened}`).width;
  const flowerLbl   = `ğŸŒ¸ ${S.flowersSold}`;
  const flowerLblW  = ctx.measureText(flowerLbl).width;
  const totalW      = miniPackW + iconGap + packNumW + groupGap + flowerLblW;
  const startX      = W / 2 - totalW / 2;
  const midY        = HEADER_H / 2;

  drawMiniPack(startX, midY - miniH / 2, miniH);

  ctx.fillStyle    = TEXT_DIM;
  ctx.textAlign    = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(` ${S.packsOpened}`, startX + miniPackW + iconGap, midY);
  ctx.fillText(flowerLbl, startX + miniPackW + iconGap + packNumW + groupGap, midY);

  ctx.textBaseline = 'alphabetic';

  drawLangButton();
}

function drawLangButton() {
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  strokeRRect(bx, by, bw, bh, 6);

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawMain(now) {
  drawHeader();
  drawHarryIndicator(now);
  drawPack(now);
  drawBins(now);
  drawPieces(now, false);
  drawPieces(now, true);
  drawShopButton(now);
}

function drawShopButton(_now) {
  shopBackBounds  = null;
  shopBuyBtns     = [];
  shopResetBounds = null;

  const cx = Math.round((INDICATOR_CX + INDICATOR_OUTER_R + W) / 2);
  const cy = INDICATOR_CY;
  const r  = 18;

  shopBtnBounds = { x: cx - r, y: cy - r, w: r * 2, h: r * 2 };

  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = BG;
  ctx.fill();
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 1.5;
  ctx.stroke();

  ctx.font         = '18px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('ğŸ›', cx, cy + 1);
  ctx.textAlign    = 'left';
  ctx.textBaseline = 'alphabetic';
}

function drawPack(now) {
  if (S.phase !== 'pack' || !S.pack) return;

  // Enter animation â€“ packEnterStart may be in the future (delay after sort)
  const enterT  = clamp01((now - packEnterStart) / 300);
  const enterSc = easeOutBack(enterT);

  // Tap wobble
  const wobbleAge = packVisual.lastTapAt > 0 ? now - packVisual.lastTapAt : Infinity;
  const wobbleT   = wobbleAge < 220 ? clamp01(wobbleAge / 220) : 1;
  const wobbleSc  = wobbleAge < 220 ? 1 + Math.sin(wobbleT * Math.PI) * 0.09 : 1;

  // Damage progress (0 = fresh, 1 = about to burst)
  const progress = 1 - S.pack.tapsLeft / S.pack.tapsRequired;

  const bw = BAG_PX * 0.72;
  const bh = BAG_PX * 1.05;

  ctx.save();
  ctx.translate(PLAY_CX, PLAY_CY);
  ctx.rotate(packVisual.angle);
  ctx.scale(enterSc * wobbleSc, enterSc * wobbleSc);
  drawFoilBag(ctx, bw, bh, progress, now, S.pack.harryPack);
  ctx.restore();
}

function drawMiniPack(x, y, h) {
  const w  = Math.round(h * 0.72);
  const r  = 2;

  const grad = ctx.createLinearGradient(x, y, x + w, y + h);
  grad.addColorStop(0.00, '#1e2e44');
  grad.addColorStop(0.40, '#253550');
  grad.addColorStop(1.00, '#131e30');
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, r);
  ctx.fillStyle = grad;
  ctx.fill();

  ctx.save();
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, r);
  ctx.clip();
  const hg = ctx.createLinearGradient(x, y, x + w * 0.4, y);
  hg.addColorStop(0, 'rgba(255,255,255,0.10)');
  hg.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hg;
  ctx.fillRect(x, y, w * 0.4, h);
  ctx.restore();

  const sealH = Math.max(2, Math.round(h * 0.22));
  ctx.fillStyle = 'rgba(200,215,255,0.12)';
  ctx.beginPath();
  ctx.roundRect(x + 1, y, w - 2, sealH, [r, r, 0, 0]);
  ctx.fill();

  ctx.strokeStyle = 'rgba(140,160,200,0.25)';
  ctx.lineWidth   = 0.75;
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, r);
  ctx.stroke();

  return w;
}

// Draws an opaque foil bag centered at (0, 0) in the current transform space.
function drawFoilBag(ctx, bw, bh, progress, now, harry = false) {
  const bx = -bw / 2, by = -bh / 2;
  const r  = 8;
  const deform = progress * bw * 0.12;

  const bagPath = () => {
    ctx.beginPath();
    if (progress > 0.08) {
      ctx.moveTo(bx + r, by);
      ctx.lineTo(bx + bw - r, by);
      ctx.bezierCurveTo(bx + bw, by,        bx + bw, by + r,
                        bx + bw - deform * 0.3, by + bh * 0.38);
      ctx.lineTo(bx + bw, by + bh - r);
      ctx.bezierCurveTo(bx + bw, by + bh,   bx + bw - r, by + bh,
                        bx + bw * 0.5 + deform * 0.2, by + bh);
      ctx.lineTo(bx + bw * 0.5 - deform * 0.2, by + bh);
      ctx.bezierCurveTo(bx + r, by + bh,    bx, by + bh,
                        bx + deform * 0.3, by + bh * 0.38);
      ctx.lineTo(bx, by + r);
      ctx.bezierCurveTo(bx, by, bx + r, by, bx + r, by);
    } else {
      ctx.roundRect(bx, by, bw, bh, r);
    }
    ctx.closePath();
  };

  // Glow aura
  if (progress > 0 || harry) {
    const pulse = 0.6 + 0.4 * Math.sin(now / (harry && progress === 0 ? 1400 : (220 - progress * 120)));
    ctx.save();
    if (harry) {
      ctx.shadowColor = `rgba(244,143,177,${(progress > 0 ? 0.7 : 0.45) * pulse})`;
      ctx.shadowBlur  = (progress > 0 ? progress * 32 : 14) * pulse;
      ctx.strokeStyle = `rgba(244,143,177,${(progress > 0 ? progress * 0.45 : 0.25) * pulse})`;
    } else {
      ctx.shadowColor = `rgba(140,185,255,${0.7 * pulse})`;
      ctx.shadowBlur  = progress * 32 * pulse;
      ctx.strokeStyle = `rgba(140,185,255,${progress * 0.45 * pulse})`;
    }
    ctx.lineWidth = 2.5;
    bagPath();
    ctx.stroke();
    ctx.restore();
  }

  // Main fill
  const grad = ctx.createLinearGradient(bx, by, bx + bw, by + bh);
  if (harry) {
    grad.addColorStop(0.00, '#2e1a20');
    grad.addColorStop(0.25, '#38202a');
    grad.addColorStop(0.55, '#2a1820');
    grad.addColorStop(1.00, '#1a0e14');
  } else {
    grad.addColorStop(0.00, '#1e2e44');
    grad.addColorStop(0.25, '#253550');
    grad.addColorStop(0.55, '#1b2a3e');
    grad.addColorStop(1.00, '#131e30');
  }
  bagPath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Left-edge foil highlight
  ctx.save();
  bagPath();
  ctx.clip();
  const hGrad = ctx.createLinearGradient(bx, by, bx + bw * 0.32, by);
  hGrad.addColorStop(0, harry ? 'rgba(244,143,177,0.10)' : 'rgba(255,255,255,0.07)');
  hGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hGrad;
  ctx.fillRect(bx, by, bw * 0.32, bh);
  ctx.restore();

  // Heat seal at top
  ctx.fillStyle = harry ? 'rgba(244,143,177,0.10)' : 'rgba(200,215,255,0.08)';
  ctx.beginPath();
  ctx.roundRect(bx + 2, by, bw - 4, 15, [r, r, 0, 0]);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth   = 1;
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.moveTo(bx + 8, by + 4 + i * 4);
    ctx.lineTo(bx + bw - 8, by + 4 + i * 4);
    ctx.stroke();
  }

  // Placeholder label area
  ctx.strokeStyle = 'rgba(255,255,255,0.055)';
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.roundRect(bx + 10, by + bh * 0.30, bw - 20, bh * 0.24, 3);
  ctx.stroke();
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.moveTo(bx + 18, by + bh * 0.38 + i * 7);
    ctx.lineTo(bx + bw - 18, by + bh * 0.38 + i * 7);
    ctx.stroke();
  }

  // Crumple marks â€“ appear gradually from 30% damage
  if (progress > 0.3) {
    const a = (progress - 0.3) / 0.7;
    ctx.strokeStyle = `rgba(255,255,255,${a * 0.18})`;
    ctx.lineWidth   = 0.8;
    const crumples = [
      [[-bw * 0.22, -bh * 0.20], [-bw * 0.06, -bh * 0.04], [-bw * 0.28,  bh * 0.07]],
      [[ bw * 0.12,  bh * 0.04], [ bw * 0.30,  bh * 0.19], [ bw * 0.08,  bh * 0.30]],
    ];
    for (const c of crumples) {
      ctx.beginPath();
      ctx.moveTo(c[0][0], c[0][1]);
      for (let i = 1; i < c.length; i++) ctx.lineTo(c[i][0], c[i][1]);
      ctx.stroke();
    }
  }

  // Bag outline
  bagPath();
  if (harry) {
    ctx.strokeStyle = progress > 0
      ? `rgba(244,143,177,${0.30 + progress * 0.38})`
      : 'rgba(244,143,177,0.30)';
  } else {
    ctx.strokeStyle = progress > 0
      ? `rgba(140,185,255,${0.22 + progress * 0.38})`
      : 'rgba(255,255,255,0.10)';
  }
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Harry's personal touch â€“ cat emoji on the bag face
  if (harry) {
    const fontSize = Math.round(bh * 0.38);
    ctx.font         = `${fontSize}px system-ui`;
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    ctx.globalAlpha  = 0.85;
    ctx.fillText('ğŸ±', 0, bh * 0.06);
    ctx.globalAlpha  = 1;
  }
}

function drawPieces(now, dragOnly = false) {
  for (const piece of pieces) {
    const isDragged = piece.phase === 'dragging';
    if (dragOnly !== isDragged) continue;
    const a = pieceAnim(piece, now);
    if (a.opacity < 0.01) continue;

    ctx.globalAlpha = a.opacity;
    if (piece.phase === 'dragging') {
      ctx.shadowColor = piece.color.hex;
      ctx.shadowBlur  = 22;
    }

    ctx.fillStyle = piece.color.hex;
    drawShapePath(piece.shape, a.x, a.y, PIECE_SIZE * a.scale);
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 4; i++) {
    const bin    = S.bins[i];
    const bx     = binX(i);
    const by     = BIN_Y;
    const recipe = config.FLOWER_RECIPE[bin.shape.id];
    const count  = bin.pieces.length;

    const flashAge = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash    = flashAge < 600 ? 1 - flashAge / 600 : 0;

    const extras    = Math.max(0, count - recipe);
    const tintAlpha = Math.min(extras / recipe, 1) * 0.18;
    ctx.fillStyle = BG;
    fillRRect(bx, by, BIN_W, BIN_H, BIN_R);

    if (tintAlpha > 0) {
      ctx.globalAlpha = tintAlpha;
      ctx.fillStyle   = '#58a6ff';
      fillRRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.globalAlpha = 1;
    }

    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.18 + flash * 0.35;
      ctx.fillStyle   = TEXT_HI;
      const fillH = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    if (flash > 0) { ctx.shadowColor = TEXT_HI; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = flash > 0 ? TEXT_HI : BORDER;
    ctx.lineWidth   = 2;
    strokeRRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.shadowBlur  = 0;

    ctx.globalAlpha = 0.3 + flash * 0.5;
    ctx.fillStyle   = TEXT_HI;
    drawShapePath(bin.shape, binCX(i), BIN_Y + BIN_H / 2, 30);
    ctx.fill();
    ctx.globalAlpha = 1;

    const isFull = count >= recipe;
    ctx.font         = '11px system-ui';
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle    = TEXT_HI;
    ctx.globalAlpha  = isFull ? (0.7 + flash * 0.3) : 0.35;
    ctx.fillText(`${count} / ${recipe}`, bx + BIN_W / 2, by + BIN_H + 6);
    ctx.globalAlpha  = 1;
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
  }
}

// â”€â”€ Shop screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawShop(now) {
  shopBtnBounds   = null;
  shopResetBounds = null;

  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  const hh = HEADER_H;
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, hh);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 1;
  ctx.beginPath(); ctx.moveTo(0, hh); ctx.lineTo(W, hh); ctx.stroke();

  const backLabel = t('shop_back');
  ctx.font      = '13px system-ui';
  const bw = ctx.measureText(backLabel).width + 24;
  const bh = 28, bx = 14, by = (hh - bh) / 2;
  shopBackBounds = { x: bx, y: by, w: bw, h: bh };
  ctx.strokeStyle  = BORDER; ctx.lineWidth = 1;
  strokeRRect(bx, by, bw, bh, 6);
  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle'; ctx.textAlign = 'left';
  ctx.fillText(backLabel, bx + 12, hh / 2);

  ctx.font         = 'bold 16px system-ui';
  ctx.fillStyle    = TEXT_HI;
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(t('shop_title'), W / 2, hh / 2);
  ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';

  drawLangButton();

  shopBuyBtns = [];
  const PAD  = 15;
  const IW   = W - PAD * 2;
  let   iy   = hh + 14;
  const nextIdx = S.upgrades.purchased.length;

  for (let i = 0; i < config.UPGRADE_TREE.length; i++) {
    const upg         = config.UPGRADE_TREE[i];
    const isPurchased = S.upgrades.purchased.includes(upg.id);
    const isNext      = i === nextIdx;
    const isLocked    = !isPurchased && !isNext;

    iy = drawUpgradeItem(upg, iy, PAD, IW, isPurchased, isNext, isLocked);
    iy += 8;
  }

  iy += 8;
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 1;
  ctx.globalAlpha = 0.4;
  ctx.beginPath(); ctx.moveTo(PAD, iy); ctx.lineTo(W - PAD, iy); ctx.stroke();
  ctx.globalAlpha = 1;
  iy += 16;

  const rih = 80;
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  fillRRect(PAD, iy, IW, rih, 8);
  ctx.fillStyle = 'rgba(110,118,129,0.3)';
  fillRRect(PAD, iy, 3, rih, [2, 0, 0, 2]);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 1;
  ctx.globalAlpha = 0.3;
  strokeRRect(PAD, iy, IW, rih, 8);
  ctx.globalAlpha = 1;

  ctx.font         = '22px system-ui';
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText('ğŸ‘½ğŸ·', PAD + 14, iy + rih / 2);

  ctx.font      = 'bold 13px system-ui';
  ctx.fillStyle = TEXT_DIM;
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(t('shop_reset_name'), PAD + 62, iy + 22);

  ctx.font        = '11px system-ui';
  ctx.fillStyle   = TEXT_DIM;
  ctx.globalAlpha = 0.6;
  ctx.fillText(t('shop_reset_desc'), PAD + 62, iy + 40);
  ctx.globalAlpha = 1;

  ctx.font      = '11px system-ui';
  ctx.fillStyle = '#f85149';
  ctx.fillText(t('shop_reset_confirm'), PAD + 62, iy + 58);

  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';

  shopResetBounds = { x: PAD, y: iy, w: IW, h: rih };
}

function drawUpgradeItem(upg, iy, px, iw, isPurchased, isNext, isLocked) {
  const acColor = ACTOR_COLOR[upg.actor];
  const name    = upg.name[lang];
  const desc    = upg.desc[lang];

  const ih = isNext ? 92 : (isPurchased ? 64 : 44);

  ctx.fillStyle = isPurchased ? 'rgba(255,255,255,0.03)' :
                  isNext      ? 'rgba(255,255,255,0.06)' :
                                'rgba(255,255,255,0.02)';
  fillRRect(px, iy, iw, ih, 8);

  ctx.fillStyle = isPurchased ? 'rgba(110,118,129,0.4)' :
                  isNext      ? acColor :
                                'rgba(110,118,129,0.2)';
  fillRRect(px, iy, 3, ih, [2, 0, 0, 2]);

  ctx.strokeStyle = isNext ? acColor : BORDER;
  ctx.lineWidth   = isNext ? 1.5 : 1;
  ctx.globalAlpha = isNext ? 0.6 : 0.4;
  strokeRRect(px, iy, iw, ih, 8);
  ctx.globalAlpha = 1;

  if (isLocked) {
    ctx.font         = '13px system-ui';
    ctx.fillStyle    = TEXT_DIM;
    ctx.globalAlpha  = 0.4;
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'left';
    ctx.fillText(t('shop_locked'), px + 18, iy + ih / 2);
    ctx.font      = '14px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('ğŸ”’', px + iw - 14, iy + ih / 2);
    ctx.globalAlpha  = 1;
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
    return iy + ih;
  }

  const actorLabel = t(`actor_${upg.actor}`);
  ctx.font = '10px system-ui';
  const alw = ctx.measureText(actorLabel).width + 10;
  ctx.fillStyle   = acColor;
  ctx.globalAlpha = isPurchased ? 0.4 : 0.9;
  fillRRect(px + 10, iy + 8, alw, 16, 8);
  ctx.globalAlpha = 1;
  ctx.fillStyle    = isPurchased ? TEXT_DIM : '#0d1117';
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'center';
  ctx.fillText(actorLabel, px + 10 + alw / 2, iy + 16);

  ctx.font         = isPurchased ? '13px system-ui' : 'bold 14px system-ui';
  ctx.fillStyle    = isPurchased ? TEXT_DIM : TEXT_HI;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(name, px + 10 + alw + 8, iy + 16);

  if (isNext || isPurchased) {
    ctx.font         = '11px system-ui';
    ctx.fillStyle    = TEXT_DIM;
    ctx.globalAlpha  = isPurchased ? 0.45 : 1;
    ctx.textBaseline = 'top';
    const maxW = iw - 20;
    const descLines = wrapText(desc, maxW).slice(0, 2);
    descLines.forEach((l, li) => {
      ctx.fillText(l, px + 10, iy + 32 + li * 14);
    });
    ctx.globalAlpha = 1;
  }

  if (isPurchased) {
    ctx.font         = '11px system-ui';
    ctx.fillStyle    = TEXT_DIM;
    ctx.globalAlpha  = 0.5;
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'right';
    ctx.fillText(t('shop_owned'), px + iw - 12, iy + 16);
    ctx.globalAlpha  = 1;
  } else {
    const costLabel = `ğŸ’° ${formatCoins(upg.cost)}`;
    ctx.font         = '12px system-ui';
    ctx.fillStyle    = TEXT_DIM;
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'right';
    ctx.fillText(costLabel, px + iw - 80, iy + ih - 18);

    const canAfford = S.coins >= upg.cost;
    const btnW = 64, btnH = 28;
    const btnX = px + iw - btnW - 10, btnY = iy + ih - btnH - 8;

    ctx.fillStyle   = canAfford ? acColor : 'rgba(110,118,129,0.25)';
    ctx.globalAlpha = canAfford ? 1 : 0.7;
    fillRRect(btnX, btnY, btnW, btnH, 6);
    ctx.globalAlpha = 1;

    ctx.font         = 'bold 12px system-ui';
    ctx.fillStyle    = canAfford ? '#0d1117' : TEXT_DIM;
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(t('shop_buy'), btnX + btnW / 2, btnY + btnH / 2);

    if (canAfford) {
      shopBuyBtns.push({ id: upg.id, x: btnX, y: btnY, w: btnW, h: btnH });
    }
  }

  ctx.textAlign    = 'left';
  ctx.textBaseline = 'alphabetic';
  return iy + ih;
}

// â”€â”€ Intro sequence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawIntro(now) {
  introSkipBounds = null;

  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  ctx.font         = '72px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('ğŸ±', W / 2, H * 0.30);

  const text    = INTRO_SLIDES[lang][introSlide];
  const maxW    = W - 64;
  const lineH   = 28;
  ctx.font      = '17px system-ui';
  ctx.fillStyle = TEXT_HI;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const lines   = wrapText(text, maxW);
  const blockH  = lines.length * lineH;
  const blockY  = H * 0.52 - blockH / 2;
  lines.forEach((line, i) => {
    ctx.fillText(line, W / 2, blockY + i * lineH + lineH / 2);
  });

  if (introSlide === INTRO_SLIDES.de.length - 1) {
    const scale  = 0.55;
    const mbw    = BAG_PX * 0.72 * scale;
    const mbh    = BAG_PX * 1.05 * scale;
    const packCY = H * 0.70;

    ctx.save();
    ctx.translate(W / 2, packCY);
    drawFoilBag(ctx, mbw, mbh, 0, now, true);
    ctx.restore();
  }

  const n        = INTRO_SLIDES.de.length;
  const dotR     = 3;
  const dotGap   = 14;
  const dotY     = H - 55;
  const dotStart = W / 2 - (n - 1) * dotGap / 2;
  for (let i = 0; i < n; i++) {
    ctx.beginPath();
    ctx.arc(dotStart + i * dotGap, dotY, dotR, 0, Math.PI * 2);
    ctx.fillStyle   = i === introSlide ? TEXT_HI : 'rgba(255,255,255,0.2)';
    ctx.globalAlpha = 1;
    ctx.fill();
  }

  const skipLabel = t('intro_skip');
  ctx.font        = '12px system-ui';
  const sw = ctx.measureText(skipLabel).width + 20;
  const sh = 26, sx = W - sw - 14, sy = 14;
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 1;
  ctx.globalAlpha = 0.5;
  strokeRRect(sx, sy, sw, sh, 5);
  ctx.globalAlpha = 1;
  ctx.fillStyle    = TEXT_DIM;
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(skipLabel, sx + sw / 2, sy + sh / 2);

  introSkipBounds = { x: sx, y: sy, w: sw, h: sh };

  ctx.textAlign    = 'left';
  ctx.textBaseline = 'alphabetic';
}

// â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop(now) {
  // Advance engine virtual time by the real elapsed delta.
  // Events from tick() trigger haptics, saves, and other side effects.
  if (lastFrameTime > 0) {
    const dt = now - lastFrameTime;
    const { state: newS, events } = engineTick(S, config, dt, Math.random);
    S = newS;
    handleEvents(events);
  }
  lastFrameTime = now;

  update(now);

  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  if      (currentScreen === 'intro') drawIntro(now);
  else if (currentScreen === 'shop')  drawShop(now);
  else                                drawMain(now);

  requestAnimationFrame(loop);
}

// â”€â”€ Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAVE_KEY = 'bfm-save';

function saveState() {
  const data = {
    bins:               S.bins,
    buildQueue:         S.buildQueue,
    stock:              S.stock,
    coins:              S.coins,
    flowerIdCounter:    S.flowerIdCounter,
    packsOpened:        S.packsOpened,
    flowersSold:        S.flowersSold,
    upgradesPurchased:  S.upgrades.purchased,
    sparscheinBalance:  S.sparschein.balance,
    sparscheinPayments: S.sparschein.paymentCount,
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
}

// Returns true if save data was found and applied, false on first launch / post-reset.
function loadState() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return false;
  try {
    const d = JSON.parse(raw);
    if (!d) return false;

    S.bins                   = d.bins         || config.SHAPES.map(s => ({ shape: s, pieces: [] }));
    S.buildQueue             = d.buildQueue    || [];
    S.stock                  = d.stock         || [];
    S.coins                  = d.coins         ?? config.STARTING_COINS;
    S.flowerIdCounter        = d.flowerIdCounter  || 0;
    S.packsOpened            = d.packsOpened      || 0;
    S.flowersSold            = d.flowersSold      || 0;
    S.upgrades.purchased     = d.upgradesPurchased  || [];
    S.sparschein.balance     = d.sparscheinBalance  || 0;
    S.sparschein.paymentCount = d.sparscheinPayments || 0;

    return true;
  } catch (e) {
    console.error('Failed to load state', e);
    return false;
  }
}

// â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// Start with a fresh engine state, then overlay saved data if it exists.
S = createState(config);

const hasState = loadState();
if (hasState) {
  // Returning player â€“ resume where they left off.
  // tick() auto-starts build/sell timers on next frame if queue/stock is non-empty.
  // Spawn a pack to fill the play area (no charge â€“ continuation of saved session).
  dispatch({ type: 'spawn_pack', charge: false });
} else {
  // First launch or post-reset â€“ show intro, Harry Pack spawns after the last slide.
  currentScreen = 'intro';
}

requestAnimationFrame(loop);
</script>

</body>
</html>

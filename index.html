<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blumen fÃ¼r Mutti</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Bâ™¥M">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
      touch-action: none;
    }

    /* On actual phone: no frame */
    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script>
// â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// â”€â”€ i18n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STRINGS = {
  de: {
    lang_toggle:        'EN',
    building_one:       'Harry baut 1 Blume â€¦',
    building_many:      (n) => `Harry baut ${n} Blumen â€¦`,
    building_idle_mine: 'teile sortieren um blumen zu erschaffen',
    mutti_selling:      'Mutti verkauft â€¦',
  },
  en: {
    lang_toggle:        'DE',
    building_one:       'Harry is building 1 flower â€¦',
    building_many:      (n) => `Harry is building ${n} flowers â€¦`,
    building_idle_mine: 'sort parts to grow flowers',
    mutti_selling:      'Mutti is selling â€¦',
  },
};

let lang = localStorage.getItem('bfm-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Flower recipe â€“ how many sorted shards per bin make one flower part
const FLOWER_RECIPE     = { circle: 1, heart: 8, stem: 3, leaf: 2 };
const BUILD_BASE_MS     = 20000;  // Harry's build time in ms (Â±15% random variance)
const SELL_BASE_MS      = 8000;   // Mutti's sell time in ms (Â±15% random variance)
const FLOWER_COIN_VALUE = 10;     // coins per flower sold (TÃ¼ten-QualitÃ¤t upgrade scales this)
let   flowerIdCounter   = 0;

// â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// â”€â”€ Shapes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SHAPES = [
  { id: 'circle' },
  { id: 'heart'  },
  { id: 'stem'   },
  { id: 'leaf'   },
];

// Weighted shape spawn â€“ probabilities match recipe ratios (total 14 parts)
const SHAPE_WEIGHTS = [
  { shape: SHAPES[0], w: 1 },   // circle  1/14
  { shape: SHAPES[1], w: 8 },   // heart   8/14
  { shape: SHAPES[2], w: 3 },   // stem    3/14
  { shape: SHAPES[3], w: 2 },   // leaf    2/14
];
const SHAPE_WEIGHT_TOTAL = SHAPE_WEIGHTS.reduce((s, e) => s + e.w, 0);

function randomShape() {
  let r = Math.random() * SHAPE_WEIGHT_TOTAL;
  for (const entry of SHAPE_WEIGHTS) {
    r -= entry.w;
    if (r <= 0) return entry.shape;
  }
  return SHAPE_WEIGHTS[SHAPE_WEIGHTS.length - 1].shape;
}

// â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const HEADER_H    = 50;
const INDICATOR_R = 80;
const INDICATOR_CX = W / 2;                                      // 215
const INDICATOR_CY = HEADER_H + INDICATOR_R + 10;                // 140
const BIN_H     = 96,  BIN_W = 80, BIN_GAP = 12, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;                               // 800
const BIN_TOTAL = 4 * BIN_W + 3 * BIN_GAP;                      // 356
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                          // 37
const PLAY_Y    = INDICATOR_CY + INDICATOR_R + 32;               // 252
const PLAY_H    = BIN_Y - PLAY_Y - 20;                          // 528
const PLAY_CX   = W / 2;                                        // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                          // ~516

// Outer ring for Mutti's sell timer (same center as Harry's indicator)
const INDICATOR_OUTER_R = 88;   // inner=80 Harry, outer=88 Mutti (8px gap)

// Shard landing zones â€“ offsets from play-area center (12 for jackpot blocks)
const SHARD_ZONES = [
  { dx:    0, dy: -115 },
  { dx: -100, dy:  -55 },
  { dx: -100, dy:   60 },
  { dx:    0, dy:  115 },
  { dx:  100, dy:   60 },
  { dx:  100, dy:  -55 },
  { dx:  -45, dy: -160 },
  { dx:   45, dy: -155 },
  { dx: -160, dy:   10 },
  { dx:  155, dy:   15 },
  { dx:  -55, dy:  165 },
  { dx:   60, dy:  160 },
];

const SHARD_SIZE = 60;

// Bag properties â€“ fixed for now, upgrades will scale these later
const BAG_PX       = 90;   // visual size of the bag
const BAG_SHARDS   = 3;    // parts per bag (TÃ¼ten-QuantitÃ¤t upgrade scales this)
const BAG_TAPS = 5;        // taps to open (Schere upgrade reduces this: 5 â†’ 3 â†’ 1)


// â”€â”€ Pfingstrose color system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PEONY_PETAL_POOL = [
  '#fce4ec', '#f8bbd9', '#f48fb1', '#f06292',
  '#e91e8c', '#c2185b', '#880e4f',
];

// Slightly shift a hex color by Â±range per channel â€“ keeps colors organic
function varyColor(hex, range = 12) {
  const p = (i) => parseInt(hex.slice(i, i + 2), 16);
  const r = p(1), g = p(3), b = p(5);
  const clamp = v => Math.max(0, Math.min(255, Math.round(v)));
  const vary  = () => (Math.random() - 0.5) * 2 * range;
  return '#' + [r + vary(), g + vary(), b + vary()]
    .map(v => clamp(v).toString(16).padStart(2, '0')).join('');
}

// Maps a shape to its Pfingstrose color
function shapeToColor(shapeId) {
  switch (shapeId) {
    case 'circle': return varyColor('#fff176', 10);
    case 'heart':  return PEONY_PETAL_POOL[Math.floor(Math.random() * PEONY_PETAL_POOL.length)];
    case 'stem':   return varyColor('#52b788', 12);
    case 'leaf':   return varyColor('#1e4d2b', 10);
    default:       return '#ffffff';
  }
}

// â”€â”€ Easing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

// Format coins with locale-aware thousand separator (DE: 1.250, EN: 1,250)
function formatCoins(n) {
  return n.toLocaleString(lang === 'de' ? 'de-DE' : 'en-US');
}

// â”€â”€ Haptics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// Button bounds â€“ set each frame during draw, used by hitTest
let langBtnBounds = null;

// â”€â”€ Drag state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const drag = {
  active:  false,
  shardId: null,
  x:       0,
  y:       0,
};

// â”€â”€ Game state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let shardIdCounter = 0;

const state = {
  phase:    'block',   // 'block' | 'shards'
  block:    null,
  shards:   [],
  selected: null,
  bins:     SHAPES.map(s => ({ shape: s, shards: [] })),
};

// Dev counter â€“ bags opened, useful for economy calibration
let bagsOpened = 0;

// Flower system â€“ separate from game state
const flowers = {
  building: [],   // { id, parts } â€“ Harry's build queue (sequential)
  stock:    [],   // { id, parts } â€“ Lager: finished, waiting for Mutti
  coins:    100,  // TODO: replace with proper starting capital (Bag economy step)
};

// Build timer â€“ runtime only, not persisted
let buildTimerActive = false;
let buildStartedAt   = 0;
let buildDurationMs  = 0;

// Sell timer â€“ runtime only, not persisted
let sellTimerActive = false;
let sellStartedAt   = 0;
let sellDurationMs  = 0;

// â”€â”€ Animation state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let blockEnterStart = 0;
const binFillAnim   = Array(4).fill(0);  // lerps toward fill target (0â†’1, clamps at 1)
const binFlashAt    = Array(4).fill(0);  // timestamp of last recipe-threshold event

// â”€â”€ Game logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

// Normalized positions for the 3 parts inside a bag
const PIECE_LAYOUT = [[ 0, -1 ], [-0.9, 0.7], [ 0.9, 0.7]];

function genPieces() {
  const spread    = BAG_PX * 0.17;
  const pieceSize = BAG_PX * 0.58;
  return PIECE_LAYOUT.map(([nx, ny]) => {
    const shape = randomShape();
    return {
      shape,
      color: shapeToColor(shape.id),
      x:     nx * spread + (Math.random() - 0.5) * spread * 0.3,
      y:     ny * spread + (Math.random() - 0.5) * spread * 0.3,
      size:  pieceSize,
      angle: (Math.random() - 0.5) * 0.5,
    };
  });
}

function spawnBlock() {
  state.phase    = 'block';
  state.shards   = [];
  state.selected = null;

  state.block = {
    px:           BAG_PX,
    pieces:       genPieces(),
    tapsRequired: BAG_TAPS,
    tapsLeft:     BAG_TAPS,
    lastTapAt:    0,
    angle:        0,
  };
  blockEnterStart = performance.now();
}

function tapBlock() {
  if (state.phase !== 'block') return;
  const block = state.block;

  block.lastTapAt    = performance.now();
  block.angle += (Math.random() - 0.5) * 0.25;
  block.tapsLeft--;

  if (block.tapsLeft <= 0) {
    haptic([10, 20, 10]);
    doBreakBlock();
  } else {
    haptic(8);
  }
}

function doBreakBlock() {
  if (state.phase !== 'block') return;

  state.phase = 'shards';
  bagsOpened++;
  const now   = performance.now();
  const zones = [...SHARD_ZONES].sort(() => Math.random() - 0.5);

  state.block.pieces.forEach((piece, i) => {
    state.shards.push({
      id:         shardIdCounter++,
      color:      { hex: piece.color },
      shape:      piece.shape,
      targetX:    PLAY_CX + jitter(zones[i].dx),
      targetY:    PLAY_CY + jitter(zones[i].dy),
      flyStart:   now,
      phase:      'flying',
      sortStart:  0,
      shakeStart: 0,
    });
  });
}

function trySortShard(binIndex) {
  if (state.selected === null) return;

  const shard = state.shards.find(s => s.id === state.selected);
  if (!shard) return;

  if (shard.shape.id !== state.bins[binIndex].shape.id) {
    // Wrong bin â€“ place at drop position, shake for feedback
    haptic([8, 30, 8]);
    shard.targetX   = drag.x;
    shard.targetY   = drag.y;
    shard.phase     = 'idle';
    shard.shakeStart = performance.now();
    state.selected  = null;
    return;
  }

  // âœ“ Correct sort
  haptic(12);
  shard.targetX   = drag.x;
  shard.targetY   = drag.y;
  shard.phase     = 'sorting';
  shard.sortStart = performance.now();
  state.selected  = null;

  setTimeout(() => {
    state.shards = state.shards.filter(s => s.id !== shard.id);

    const bin    = state.bins[binIndex];
    const recipe = FLOWER_RECIPE[bin.shape.id];
    bin.shards.push({ color: shard.color.hex });

    // Flash when we cross a recipe threshold
    if (bin.shards.length % recipe === 0) {
      binFlashAt[binIndex] = performance.now();
      haptic([18, 10, 18]);
    }

    checkBuildTrigger();

    if (state.shards.length === 0) {
      setTimeout(spawnBlock, 350);
    }
    saveState();
  }, 230);
}

// â”€â”€ Flower system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function flowersReady() {
  return Math.min(...SHAPES.map(s => {
    const bin = state.bins.find(b => b.shape.id === s.id);
    return Math.floor(bin.shards.length / FLOWER_RECIPE[s.id]);
  }));
}

function checkBuildTrigger() {
  while (flowersReady() > 0) {
    // Consume shards from bins
    for (const s of SHAPES) {
      state.bins.find(b => b.shape.id === s.id).shards.splice(0, FLOWER_RECIPE[s.id]);
    }

    // Assign Pfingstrose colors via shapeToColor
    const parts = {
      circle: [{ color: shapeToColor('circle') }],
      heart:  Array.from({ length: 8 }, () => ({ color: shapeToColor('heart') })),
      stem:   Array.from({ length: 3 }, () => ({ color: shapeToColor('stem')  })),
      leaf:   Array.from({ length: 2 }, () => ({ color: shapeToColor('leaf')  })),
    };
    flowers.building.push({ id: flowerIdCounter++, parts });
    haptic([15, 10, 15]);
  }

  if (flowers.building.length > 0 && !buildTimerActive) {
    startBuildTimer();
  }
  saveState();
}

function startSellTimer() {
  if (sellTimerActive || flowers.stock.length === 0) return;
  sellTimerActive = true;
  sellDurationMs  = SELL_BASE_MS * (0.85 + Math.random() * 0.3);
  sellStartedAt   = performance.now();
  setTimeout(completeSelling, sellDurationMs);
}

function completeSelling() {
  flowers.stock.shift();
  flowers.coins += FLOWER_COIN_VALUE;
  haptic([15, 10, 30]);
  sellTimerActive = false;
  startSellTimer(); // pick up next flower if any
  saveState();
}

function startBuildTimer() {
  if (buildTimerActive || flowers.building.length === 0) return;

  buildTimerActive = true;
  buildDurationMs  = BUILD_BASE_MS * (0.85 + Math.random() * 0.3);
  buildStartedAt   = performance.now();

  setTimeout(completeBuilding, buildDurationMs);
}

function completeBuilding() {
  const flower = flowers.building.shift();
  if (!flower) return;

  flowers.stock.push({ id: flower.id, parts: flower.parts });
  haptic([20, 12, 35]);

  buildTimerActive = false;
  startSellTimer();
  checkBuildTrigger(); // Will save state
}

// â”€â”€ Shard animation helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns { x, y, scale, opacity } for the current frame
function shardAnim(shard, now) {
  if (shard.phase === 'flying') {
    const t = clamp01((now - shard.flyStart) / 450);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(PLAY_CX, shard.targetX, e),
      y:       lerp(PLAY_CY, shard.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (shard.phase === 'sorting') {
    const t = clamp01((now - shard.sortStart) / 220);
    return { x: shard.targetX, y: shard.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  if (shard.phase === 'dragging') {
    return { x: drag.x, y: drag.y, scale: 1.18, opacity: 1 };
  }

  // idle â€“ optional shake
  let shakeX = 0;
  if (shard.shakeStart) {
    const st = clamp01((now - shard.shakeStart) / 350);
    shakeX = Math.sin(st * Math.PI * 4.5) * 12 * (1 - st);
    if (st >= 1) shard.shakeStart = 0;
  }

  return { x: shard.targetX + shakeX, y: shard.targetY, scale: 1, opacity: 1 };
}

// â”€â”€ Shape paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pathCircle(ctx, cx, cy, s) {
  ctx.arc(cx, cy, s * 0.42, 0, Math.PI * 2);
}

function pathHeart(ctx, cx, cy, s) {
  const r = s * 0.42;
  const x = cx, y = cy + r * 0.2;
  ctx.moveTo(x, y + r * 0.75);
  ctx.bezierCurveTo(x - r * 0.1, y + r * 0.4,  x - r, y + r * 0.1,  x - r, y - r * 0.3);
  ctx.bezierCurveTo(x - r, y - r,               x,     y - r * 0.65, x,     y - r * 0.1);
  ctx.bezierCurveTo(x,     y - r * 0.65,        x + r, y - r,        x + r, y - r * 0.3);
  ctx.bezierCurveTo(x + r, y + r * 0.1,         x + r * 0.1, y + r * 0.4, x, y + r * 0.75);
}

function pathStem(ctx, cx, cy, s) {
  const w = s * 0.22, h = s * 0.46;
  ctx.roundRect(cx - w, cy - h, w * 2, h * 2, w);
}

function pathLeaf(ctx, cx, cy, s) {
  const h = s * 0.46, w = s * 0.28;
  ctx.moveTo(cx - h, cy);
  ctx.bezierCurveTo(cx - h * 0.3, cy - w, cx + h * 0.3, cy - w, cx + h, cy);
  ctx.bezierCurveTo(cx + h * 0.3, cy + w, cx - h * 0.3, cy + w, cx - h, cy);
}

function drawShapePath(ctx, shape, cx, cy, size) {
  ctx.beginPath();
  switch (shape.id) {
    case 'circle': pathCircle(ctx, cx, cy, size); break;
    case 'heart':  pathHeart(ctx, cx, cy, size);  break;
    case 'stem':   pathStem(ctx, cx, cy, size);   break;
    case 'leaf':   pathLeaf(ctx, cx, cy, size);   break;
  }
  ctx.closePath();
}

// â”€â”€ Hit testing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

function hitTest(x, y, now) {
  // Lang button
  if (langBtnBounds && inRect(x, y, langBtnBounds.x, langBtnBounds.y, langBtnBounds.w, langBtnBounds.h)) {
    return { type: 'lang' };
  }

  // Shards (reverse so topmost is checked first)
  if (state.phase === 'shards') {
    for (const shard of [...state.shards].reverse()) {
      if (shard.phase === 'sorting') continue;
      const a  = shardAnim(shard, now);
      const dx = x - a.x, dy = y - a.y;
      if (Math.sqrt(dx * dx + dy * dy) < SHARD_SIZE * 0.45 * a.scale) {
        return { type: 'shard', id: shard.id };
      }
    }
  }

  // Block
  if (state.phase === 'block') {
    const bw = state.block.px * 0.72;
    const bh = state.block.px * 1.05;
    if (inRect(x, y, PLAY_CX - bw / 2, PLAY_CY - bh / 2, bw, bh)) {
      return { type: 'block' };
    }
  }

  // Bins
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(x, y, bx, BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTouchEnd = 0;

function initDrag(coords) {
  const now = performance.now();
  const hit = hitTest(coords.x, coords.y, now);
  if (!hit || hit.type !== 'shard') return;

  const shard = state.shards.find(s => s.id === hit.id);
  if (!shard || shard.phase === 'sorting') return;

  haptic(8);
  drag.active  = true;
  drag.shardId = hit.id;
  drag.x       = coords.x;
  drag.y       = coords.y;
  shard.phase  = 'dragging';
  state.selected = null;
}

function updateDrag(coords) {
  if (!drag.active) return;
  drag.x = coords.x;
  drag.y = coords.y;
}

function endDrag(coords) {
  if (!drag.active) return;
  drag.active = false;

  const shard = state.shards.find(s => s.id === drag.shardId);
  drag.shardId = null;
  if (!shard) return;

  // Check if dropped on a bin
  let binIndex = -1;
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(coords.x, coords.y, bx, BIN_Y, BIN_W, BIN_H)) { binIndex = i; break; }
  }

  if (binIndex >= 0) {
    state.selected = shard.id;
    trySortShard(binIndex);
    return;
  }

  // Dropped on empty space â€“ place freely at drop position
  shard.targetX  = coords.x;
  shard.targetY  = coords.y;
  shard.phase    = 'idle';
  state.selected = null;
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updateDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
}, { passive: false });

canvas.addEventListener('mousedown',  (e) => { initDrag(canvasCoords(e)); });
canvas.addEventListener('mousemove',  (e) => { updateDrag(canvasCoords(e)); });
canvas.addEventListener('mouseup',    (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'lang':  toggleLang(); break;
    case 'block': tapBlock();   break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('bfm-lang', lang);
}

// â”€â”€ Flower draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawFlower(ctx, cx, cy, rotation, scale, parts) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  ctx.scale(scale, scale);
  ctx.translate(0, -58); // origin = bottom of stem

  // Extract colors (with fallbacks)
  const circleColor = parts.circle && parts.circle[0] ? parts.circle[0].color : '#fff176';
  const heartColors = parts.heart || [];
  const stemColors  = parts.stem  || [];
  const leafColors  = parts.leaf  || [];
  const hc = i => heartColors[i] ? heartColors[i].color : '#f48fb1';
  const sc = i => stemColors[i]  ? stemColors[i].color  : '#52b788';
  const lc = i => leafColors[i]  ? leafColors[i].color  : '#1e4d2b';

  // â”€â”€ Right leaf behind stem â€“ outer tip points upper-right â”€â”€
  ctx.save();
  ctx.translate(10, 44);
  ctx.rotate(-0.8);
  ctx.fillStyle = lc(1);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // â”€â”€ Stem (3 segments as stroked lines â€“ guaranteed connected, per-segment color) â”€â”€
  const kinks = [ {x:2,y:15}, {x:7,y:30}, {x:0,y:45}, {x:3,y:58} ];
  ctx.lineWidth = 5;
  ctx.lineCap   = 'round';
  ctx.lineJoin  = 'round';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.strokeStyle = sc(i);
    ctx.moveTo(kinks[i].x,   kinks[i].y);
    ctx.lineTo(kinks[i+1].x, kinks[i+1].y);
    ctx.stroke();
  }
  ctx.lineCap  = 'butt';
  ctx.lineJoin = 'miter';

  // â”€â”€ Left leaf in front of stem â€“ outer tip points upper-left â”€â”€
  ctx.save();
  ctx.translate(-8, 30);
  ctx.rotate(0.8);
  ctx.fillStyle = lc(0);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // â”€â”€ Petal base â€“ solid circle to block bleed-through from behind â”€â”€
  ctx.fillStyle = hc(0);
  ctx.beginPath(); pathCircle(ctx, 0, 0, 27); ctx.fill();

  // â”€â”€ Petals: 8 hearts in a ring, tips toward center â”€â”€
  const PETAL_R    = 17;
  const PETAL_SIZE = 20;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    ctx.save();
    ctx.translate(Math.cos(angle) * PETAL_R, Math.sin(angle) * PETAL_R);
    ctx.rotate(angle + Math.PI / 2);   // rotate so tip points toward center
    ctx.fillStyle = hc(i);
    ctx.beginPath(); pathHeart(ctx, 0, 0, PETAL_SIZE); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // â”€â”€ Center circle â”€â”€
  ctx.fillStyle = circleColor;
  ctx.beginPath(); pathCircle(ctx, 0, 0, 14); ctx.fill();

  ctx.restore();
}

// â”€â”€ Draw functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Draws the flower stock (Lager) inside the Harry indicator
function drawStock(cx, cy) {
  const n = flowers.stock.length;
  if (n === 0) return;

  const FAN_RAD    = 70 * Math.PI / 180;  // Â±35Â° total spread
  const MAX_VISUAL = 7;                   // cap visual flowers to avoid overcrowding
  const visible    = Math.min(n, MAX_VISUAL);

  for (let i = 0; i < visible; i++) {
    const t        = visible === 1 ? 0 : (i / (visible - 1) - 0.5);
    const rotation = t * FAN_RAD;
    drawFlower(ctx, cx, cy, rotation, 1.0, flowers.stock[i].parts);
  }
}

function drawHarryIndicator(now) {
  const cx = INDICATOR_CX, cy = INDICATOR_CY;
  const r  = INDICATOR_R;        // inner ring â€“ Harry
  const ro = INDICATOR_OUTER_R;  // outer ring â€“ Mutti

  // Harry
  const harryActive   = buildTimerActive || flowers.building.length > 0;
  const harryProgress = buildTimerActive ? clamp01((now - buildStartedAt) / buildDurationMs) : 0;
  const harryPulse    = harryActive ? 0.6 + 0.4 * Math.sin(now / 700) : 0;

  // Mutti
  const muttiActive   = sellTimerActive || flowers.stock.length > 0;
  const muttiProgress = sellTimerActive ? clamp01((now - sellStartedAt) / sellDurationMs) : 0;
  const muttiPulse    = sellTimerActive ? 0.6 + 0.4 * Math.sin(now / 500) : 0;

  // Flower stock (Lager) inside circle
  drawStock(cx, cy + 38);

  // Circle background
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = harryActive ? `rgba(13,17,23,${0.55 + harryPulse * 0.05})` : 'rgba(13,17,23,0.55)';
  ctx.fill();

  // Harry: inner track ring
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 3;
  ctx.stroke();

  // Harry: blue build arc
  if (harryActive) {
    ctx.shadowColor = '#58a6ff';
    ctx.shadowBlur  = 10 + 8 * harryPulse;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + harryProgress * Math.PI * 2);
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth   = 3;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Mutti: outer track ring â€“ always visible so the layout never jumps
  ctx.beginPath();
  ctx.arc(cx, cy, ro, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(227,179,65,0.15)';
  ctx.lineWidth   = 2.5;
  ctx.stroke();

  // Mutti: gold sell arc (only when she's actively selling)
  if (sellTimerActive) {
    ctx.shadowColor = '#e3b341';
    ctx.shadowBlur  = 10 + 8 * muttiPulse;
    ctx.beginPath();
    ctx.arc(cx, cy, ro, -Math.PI / 2, -Math.PI / 2 + muttiProgress * Math.PI * 2);
    ctx.strokeStyle = '#e3b341';
    ctx.lineWidth   = 2.5;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Center dot when completely idle and empty
  if (flowers.stock.length === 0 && flowers.coins === 0 && !harryActive) {
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(110,118,129,0.3)';
    ctx.fill();
  }

  // Coin badge â€“ at the bottom of the outer ring
  if (flowers.coins > 0) {
    const badgeY = cy + ro;
    const ph = 22, pad = 12;
    ctx.font = '12px system-ui';
    const coinLabel = `ðŸ’° ${formatCoins(flowers.coins)}`;
    const tw = ctx.measureText(coinLabel).width;
    const pw = tw + pad * 2;
    const px = cx - pw / 2, py = badgeY - ph / 2;

    ctx.fillStyle = BG;
    ctx.beginPath(); ctx.roundRect(px, py, pw, ph, ph / 2); ctx.fill();
    ctx.strokeStyle = BORDER; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.roundRect(px, py, pw, ph, ph / 2); ctx.stroke();

    ctx.fillStyle    = '#e3b341';
    ctx.textBaseline = 'middle';
    ctx.textAlign    = 'center';
    ctx.fillText(coinLabel, cx, badgeY);
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
  }

  // Labels below â€“ enough gap so they don't crowd the coin badge
  const labelBaseY = cy + ro + 30;
  ctx.font      = '11px system-ui';
  ctx.textAlign = 'center';

  let harryLabel;
  if (flowers.building.length > 1)     harryLabel = t('building_many', flowers.building.length);
  else if (flowers.building.length === 1) harryLabel = t('building_one');
  else                                  harryLabel = t('building_idle_mine');

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(harryLabel, cx, labelBaseY);

  if (muttiActive) {
    ctx.fillStyle = '#e3b341';
    ctx.fillText(t('mutti_selling'), cx, labelBaseY + 16);
  }

  ctx.textAlign = 'left';
}

function drawHeader() {
  // Bâ™¥M logo left
  ctx.fillStyle    = TEXT_HI;
  ctx.font         = 'bold 18px system-ui';
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillStyle    = '#f48fb1';
  ctx.fillText('B', 22, HEADER_H / 2);
  const bw = ctx.measureText('B').width;
  ctx.fillStyle = '#f06292';
  ctx.fillText('â™¥', 22 + bw, HEADER_H / 2);
  const hw = ctx.measureText('â™¥').width;
  ctx.fillStyle = TEXT_HI;
  ctx.fillText('M', 22 + bw + hw, HEADER_H / 2);

  // Bag counter â€“ center of header, dim (dev aid for economy tuning)
  ctx.fillStyle    = TEXT_DIM;
  ctx.font         = '11px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`ðŸ› ${bagsOpened}`, W / 2, HEADER_H / 2);
  ctx.textAlign = 'left';

  drawLangButton();
}

function drawLangButton() {
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 6);
  ctx.stroke();

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawMine(now) {
  drawHeader();
  drawHarryIndicator(now);
  drawBlock(now);
  drawBins(now);
  drawShards(now, false);
  drawShards(now, true);
}

function drawBlock(now) {
  if (state.phase !== 'block' || !state.block) return;

  const block = state.block;

  // Enter animation
  const enterT  = clamp01((now - blockEnterStart) / 300);
  const enterSc = easeOutBack(enterT);

  // Tap wobble: scale punch + rotation rattle
  const wobbleAge = block.lastTapAt > 0 ? now - block.lastTapAt : Infinity;
  const wobbleT   = wobbleAge < 220 ? clamp01(wobbleAge / 220) : 1;
  const wobbleSc  = wobbleAge < 220 ? 1 + Math.sin(wobbleT * Math.PI) * 0.09 : 1;

  // Damage progress (0 = fresh, 1 = about to burst)
  const progress = 1 - block.tapsLeft / block.tapsRequired;

  const bw = block.px * 0.72;
  const bh = block.px * 1.05;

  ctx.save();
  ctx.translate(PLAY_CX, PLAY_CY);
  ctx.rotate(block.angle);
  ctx.scale(enterSc * wobbleSc, enterSc * wobbleSc);
  drawFoilBag(ctx, bw, bh, progress, now);
  ctx.restore();
}

// Draws an opaque foil bag centered at (0, 0) in the current transform space.
// Deforms and glows as progress (0â†’1) increases.
function drawFoilBag(ctx, bw, bh, progress, now) {
  const bx = -bw / 2, by = -bh / 2;
  const r  = 8;
  const deform = progress * bw * 0.12;

  // Bag outline path â€“ deforms with damage
  const bagPath = () => {
    ctx.beginPath();
    if (progress > 0.08) {
      ctx.moveTo(bx + r, by);
      ctx.lineTo(bx + bw - r, by);
      ctx.bezierCurveTo(bx + bw, by,        bx + bw, by + r,
                        bx + bw - deform * 0.3, by + bh * 0.38);
      ctx.lineTo(bx + bw, by + bh - r);
      ctx.bezierCurveTo(bx + bw, by + bh,   bx + bw - r, by + bh,
                        bx + bw * 0.5 + deform * 0.2, by + bh);
      ctx.lineTo(bx + bw * 0.5 - deform * 0.2, by + bh);
      ctx.bezierCurveTo(bx + r, by + bh,    bx, by + bh,
                        bx + deform * 0.3, by + bh * 0.38);
      ctx.lineTo(bx, by + r);
      ctx.bezierCurveTo(bx, by, bx + r, by, bx + r, by);
    } else {
      ctx.roundRect(bx, by, bw, bh, r);
    }
    ctx.closePath();
  };

  // Glow aura â€“ pulses faster as damage increases
  if (progress > 0) {
    const pulse = 0.6 + 0.4 * Math.sin(now / (220 - progress * 120));
    ctx.save();
    ctx.shadowColor = `rgba(140,185,255,${0.7 * pulse})`;
    ctx.shadowBlur  = progress * 32 * pulse;
    ctx.strokeStyle = `rgba(140,185,255,${progress * 0.45 * pulse})`;
    ctx.lineWidth   = 2.5;
    bagPath();
    ctx.stroke();
    ctx.restore();
  }

  // Main fill â€“ dark metallic gradient
  const grad = ctx.createLinearGradient(bx, by, bx + bw, by + bh);
  grad.addColorStop(0.00, '#1e2e44');
  grad.addColorStop(0.25, '#253550');
  grad.addColorStop(0.55, '#1b2a3e');
  grad.addColorStop(1.00, '#131e30');
  bagPath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Left-edge highlight (like light catching the foil)
  ctx.save();
  bagPath();
  ctx.clip();
  const hGrad = ctx.createLinearGradient(bx, by, bx + bw * 0.32, by);
  hGrad.addColorStop(0, 'rgba(255,255,255,0.07)');
  hGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hGrad;
  ctx.fillRect(bx, by, bw * 0.32, bh);
  ctx.restore();

  // Heat seal at top
  ctx.fillStyle = 'rgba(200,215,255,0.08)';
  ctx.beginPath();
  ctx.roundRect(bx + 2, by, bw - 4, 15, [r, r, 0, 0]);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth   = 1;
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.moveTo(bx + 8, by + 4 + i * 4);
    ctx.lineTo(bx + bw - 8, by + 4 + i * 4);
    ctx.stroke();
  }

  // Placeholder label area
  ctx.strokeStyle = 'rgba(255,255,255,0.055)';
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.roundRect(bx + 10, by + bh * 0.30, bw - 20, bh * 0.24, 3);
  ctx.stroke();
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.moveTo(bx + 18, by + bh * 0.38 + i * 7);
    ctx.lineTo(bx + bw - 18, by + bh * 0.38 + i * 7);
    ctx.stroke();
  }

  // Crumple marks â€“ appear gradually from 30% damage
  if (progress > 0.3) {
    const a = (progress - 0.3) / 0.7;
    ctx.strokeStyle = `rgba(255,255,255,${a * 0.18})`;
    ctx.lineWidth   = 0.8;
    const crumples = [
      [[-bw * 0.22, -bh * 0.20], [-bw * 0.06, -bh * 0.04], [-bw * 0.28,  bh * 0.07]],
      [[ bw * 0.12,  bh * 0.04], [ bw * 0.30,  bh * 0.19], [ bw * 0.08,  bh * 0.30]],
    ];
    for (const c of crumples) {
      ctx.beginPath();
      ctx.moveTo(c[0][0], c[0][1]);
      for (let i = 1; i < c.length; i++) ctx.lineTo(c[i][0], c[i][1]);
      ctx.stroke();
    }
  }

  // Bag outline
  bagPath();
  ctx.strokeStyle = progress > 0
    ? `rgba(140,185,255,${0.22 + progress * 0.38})`
    : 'rgba(255,255,255,0.10)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function drawShards(now, dragOnly = false) {
  for (const shard of state.shards) {
    const isDragged = shard.phase === 'dragging';
    if (dragOnly !== isDragged) continue;
    const a = shardAnim(shard, now);
    if (a.opacity < 0.01) continue;

    ctx.globalAlpha = a.opacity;
    if (shard.phase === 'dragging') {
      ctx.shadowColor = shard.color.hex;
      ctx.shadowBlur  = 22;
    }

    ctx.fillStyle = shard.color.hex;
    drawShapePath(ctx, shard.shape, a.x, a.y, SHARD_SIZE * a.scale);
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 4; i++) {
    const bin    = state.bins[i];
    const bx     = BIN_LEFT + i * (BIN_W + BIN_GAP);
    const by     = BIN_Y;
    const recipe = FLOWER_RECIPE[bin.shape.id];
    const count  = bin.shards.length;

    // Fill target: 0â†’1 as count reaches recipe, clamps at full
    const fillTarget = Math.min(count / recipe, 1);
    binFillAnim[i] += (fillTarget - binFillAnim[i]) * 0.15;

    // Flash factor after hitting a recipe threshold
    const flashAge = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash    = flashAge < 600 ? 1 - flashAge / 600 : 0;

    // Background tint â€“ more saturated when bin has extra stock beyond 1 recipe
    const extras    = Math.max(0, count - recipe);
    const tintAlpha = Math.min(extras / recipe, 1) * 0.18;
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.fill();

    if (tintAlpha > 0) {
      ctx.globalAlpha = tintAlpha;
      ctx.fillStyle   = '#58a6ff';
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Fill bar â€“ fills once to 100% when count reaches recipe, stays full beyond
    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.18 + flash * 0.35;
      ctx.fillStyle   = TEXT_HI;
      const fillH = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Border
    if (flash > 0) { ctx.shadowColor = TEXT_HI; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = flash > 0 ? TEXT_HI : BORDER;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // Shape icon
    ctx.globalAlpha = 0.3 + flash * 0.5;
    ctx.fillStyle   = TEXT_HI;
    drawShapePath(ctx, bin.shape, bx + BIN_W / 2, by + BIN_H / 2, 30);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Counter below bin: "count / recipe" â€“ bright when full or over, dim when filling
    const isFull = count >= recipe;
    ctx.font         = '11px system-ui';
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle    = TEXT_HI;
    ctx.globalAlpha  = isFull ? (0.7 + flash * 0.3) : 0.35;
    ctx.fillText(`${count} / ${recipe}`, bx + BIN_W / 2, by + BIN_H + 6);
    ctx.globalAlpha  = 1;
    ctx.textAlign    = 'left';
    ctx.textBaseline = 'alphabetic';
  }
}

// â”€â”€ Game loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw(now) {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);
  drawMine(now);
  requestAnimationFrame(draw);
}

// â”€â”€ Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAVE_KEY = 'bfm-save';

function saveState() {
  const saveData = {
    bins:           state.bins,
    building:       flowers.building,
    stock:          flowers.stock,
    coins:          flowers.coins,
    flowerIdCounter,
    bagsOpened,
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
}

function loadState() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return;

  try {
    const saveData = JSON.parse(raw);
    if (!saveData) return;

    state.bins       = saveData.bins     || SHAPES.map(s => ({ shape: s, shards: [] }));
    flowers.building = saveData.building || [];
    flowers.stock    = saveData.stock    || [];
    flowers.coins    = saveData.coins    || 0;
    flowerIdCounter  = saveData.flowerIdCounter || 0;
    bagsOpened       = saveData.bagsOpened      || 0;

  } catch (e) {
    console.error('Failed to load state', e);
  }
}


// â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

loadState();
checkBuildTrigger(); // restart build timer if flowers were building
startSellTimer();    // restart sell timer if stock was waiting
spawnBlock();
requestAnimationFrame(draw);
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>knack!</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="knack!">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script>
// ── Canvas setup ───────────────────────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// ── i18n ──────────────────────────────────────────────────────────────────
const STRINGS = {
  de: {
    lang_toggle: 'EN',
    gem_label:   (n, max) => `${n} von ${max} Facetten`,
    gem_done:    '✦ Edelstein vollständig!',
  },
  en: {
    lang_toggle: 'DE',
    gem_label:   (n, max) => `${n} of ${max} facets`,
    gem_done:    '✦ gem complete!',
  },
};

let lang = localStorage.getItem('knack-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// ── Colors ─────────────────────────────────────────────────────────────────
const COLORS = [
  { id: 'blue',   hex: '#58a6ff' },
  { id: 'orange', hex: '#f0883e' },
  { id: 'purple', hex: '#bc8cff' },
];

// Each gem facet cycles through the 3 colors
const FACET_COLORS = ['#58a6ff', '#f0883e', '#bc8cff', '#58a6ff', '#f0883e', '#bc8cff'];

const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// ── Shard shapes ───────────────────────────────────────────────────────────
// Normalized [0–1] polygon coordinates – scaled to SHARD_SIZE at draw time
const SHARD_POLYS = [
  [[.5,0],[1,.3],[.85,1],[.15,1],[0,.3]],
  [[.2,0],[1,.15],[.9,.9],[0,.75]],
  [[.5,.05],[1,.45],[.65,1],[.05,.75],[0,.2]],
  [[0,.2],[.55,0],[1,.4],[.8,1],[.1,.85]],
  [[.1,0],[.95,.1],[1,.85],[.5,1],[0,.6]],
  [[.3,0],[1,.25],[.85,.95],[0,.85]],
];

// ── Layout ─────────────────────────────────────────────────────────────────
const HEADER_H  = 70;
const GEM_H     = 130;
const BIN_H     = 96,  BIN_W = 90, BIN_GAP = 16, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;                      // 800
const BIN_TOTAL = 3 * BIN_W + 2 * BIN_GAP;             // 302
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                 // 64
const PLAY_Y    = HEADER_H + GEM_H;                    // 200
const PLAY_H    = BIN_Y - PLAY_Y - 20;                 // 580
const PLAY_CX   = W / 2;                               // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                 // 490
const GEM_CX    = W / 2;
const GEM_CY    = HEADER_H + GEM_H / 2 - 10;           // 125
const GEM_R     = 38;

// Shard landing zones – offsets from play-area center
const SHARD_ZONES = [
  { dx: -95, dy: -80 },
  { dx:  95, dy: -65 },
  { dx:   0, dy: 100 },
];

const SHARD_SIZE   = 80;
const BLOCK_SIZE   = 112;
const BLOCK_R      = 22;

// ── Game constants ─────────────────────────────────────────────────────────
const SHARDS_PER_BLOCK = 3;
const BIN_CAPACITY     = 4;
const GEM_FACETS       = 6;

// ── Easing ────────────────────────────────────────────────────────────────
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

// ── Haptics ───────────────────────────────────────────────────────────────
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// ── Game state ────────────────────────────────────────────────────────────
let shardIdCounter = 0;

const state = {
  phase:    'block',   // 'block' | 'shards'
  block:    null,      // { color }
  shards:   [],        // see spawnShards()
  selected: null,      // shard id or null
  bins:     COLORS.map(c => ({ color: c, count: 0 })),
  gem:      { filled: 0 },
};

// ── Animation state ───────────────────────────────────────────────────────
let blockEnterStart = 0;
const binFillAnim   = [0, 0, 0];   // lerps toward bin.count / BIN_CAPACITY
const binFlashAt    = [0, 0, 0];   // timestamp of last bin-full event
const facetAnim     = Array(GEM_FACETS).fill(0.1);
let gemCompleteAt   = 0;

// ── Game logic ────────────────────────────────────────────────────────────
function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

function spawnBlock() {
  state.phase         = 'block';
  state.shards        = [];
  state.selected      = null;
  state.block         = { color: COLORS[Math.floor(Math.random() * COLORS.length)] };
  blockEnterStart     = performance.now();
}

function breakBlock() {
  if (state.phase !== 'block') return;
  haptic(14);

  state.phase = 'shards';
  const now   = performance.now();
  const color = state.block.color;
  const zones = [...SHARD_ZONES].sort(() => Math.random() - 0.5);

  zones.slice(0, SHARDS_PER_BLOCK).forEach(zone => {
    state.shards.push({
      id:         shardIdCounter++,
      color,
      poly:       SHARD_POLYS[Math.floor(Math.random() * SHARD_POLYS.length)],
      targetX:    PLAY_CX + jitter(zone.dx),
      targetY:    PLAY_CY + jitter(zone.dy),
      flyStart:   now,
      phase:      'flying',   // 'flying' | 'idle' | 'selected' | 'sorting'
      sortStart:  0,
      shakeStart: 0,
    });
  });
}

function selectShard(id) {
  haptic(8);

  if (state.selected === id) {
    // Tap same shard → deselect
    const s = state.shards.find(s => s.id === id);
    if (s) s.phase = 'idle';
    state.selected = null;
    return;
  }

  // Deselect previous
  if (state.selected !== null) {
    const prev = state.shards.find(s => s.id === state.selected);
    if (prev) prev.phase = 'idle';
  }

  state.selected = id;
  const shard = state.shards.find(s => s.id === id);
  if (shard) shard.phase = 'selected';
}

function trySortShard(binIndex) {
  if (state.selected === null) return;

  const shard = state.shards.find(s => s.id === state.selected);
  if (!shard) return;

  if (shard.color.id !== state.bins[binIndex].color.id) {
    haptic([8, 30, 8]);
    shard.shakeStart = performance.now();
    return;
  }

  // ✓ Correct sort
  haptic(12);
  shard.phase     = 'sorting';
  shard.sortStart = performance.now();
  state.selected  = null;

  setTimeout(() => {
    state.shards = state.shards.filter(s => s.id !== shard.id);
    state.bins[binIndex].count++;

    if (state.bins[binIndex].count >= BIN_CAPACITY) {
      onBinFilled(binIndex);
    }
    if (state.shards.length === 0) {
      setTimeout(spawnBlock, 350);
    }
  }, 230);
}

function onBinFilled(binIndex) {
  haptic([18, 10, 18]);
  state.bins[binIndex].count = 0;
  binFlashAt[binIndex] = performance.now();
  // binFillAnim stays near 1.0 and drains naturally toward 0

  state.gem.filled++;
  if (state.gem.filled >= GEM_FACETS) onGemComplete();
}

function onGemComplete() {
  haptic([25, 12, 25, 12, 40]);
  gemCompleteAt = performance.now();

  setTimeout(() => {
    state.gem.filled = 0;
    gemCompleteAt    = 0;
  }, 1800);
}

// ── Shard animation helper ────────────────────────────────────────────────
// Returns { x, y, scale, opacity } for the current frame
function shardAnim(shard, now) {
  if (shard.phase === 'flying') {
    const t = clamp01((now - shard.flyStart) / 450);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(PLAY_CX, shard.targetX, e),
      y:       lerp(PLAY_CY, shard.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (shard.phase === 'sorting') {
    const t = clamp01((now - shard.sortStart) / 220);
    return { x: shard.targetX, y: shard.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  // idle / selected – optional shake
  let shakeX = 0;
  if (shard.shakeStart) {
    const st = clamp01((now - shard.shakeStart) / 350);
    shakeX = Math.sin(st * Math.PI * 4.5) * 12 * (1 - st);
    if (st >= 1) shard.shakeStart = 0;
  }

  return { x: shard.targetX + shakeX, y: shard.targetY, scale: 1, opacity: 1 };
}

// ── Hit testing ───────────────────────────────────────────────────────────
// Point-in-polygon (ray casting) – works in logical canvas coordinates
function pointInPoly(px, py, pts) {
  let inside = false;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    const [xi, yi] = pts[i], [xj, yj] = pts[j];
    if ((yi > py) !== (yj > py) && px < ((xj - xi) * (py - yi)) / (yj - yi) + xi) {
      inside = !inside;
    }
  }
  return inside;
}

function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

let langBtnBounds = null; // set during drawHeader each frame

function hitTest(x, y, now) {
  // Lang button
  if (langBtnBounds) {
    const b = langBtnBounds;
    if (inRect(x, y, b.x, b.y, b.w, b.h)) return { type: 'lang' };
  }

  // Shards (reverse so topmost is checked first)
  if (state.phase === 'shards') {
    for (const shard of [...state.shards].reverse()) {
      if (shard.phase === 'sorting') continue;
      const a = shardAnim(shard, now);
      const s = SHARD_SIZE * a.scale;
      const pts = shard.poly.map(([nx, ny]) => [a.x + (nx - 0.5) * s, a.y + (ny - 0.5) * s]);
      if (pointInPoly(x, y, pts)) return { type: 'shard', id: shard.id };
    }
  }

  // Block
  if (state.phase === 'block') {
    const hw = BLOCK_SIZE / 2;
    if (inRect(x, y, PLAY_CX - hw, PLAY_CY - hw, BLOCK_SIZE, BLOCK_SIZE)) {
      return { type: 'block' };
    }
  }

  // Bins
  for (let i = 0; i < 3; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(x, y, bx, BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// ── Input ─────────────────────────────────────────────────────────────────
let lastTouchEnd = 0;

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  handleTap(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('click', (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  handleTap(canvasCoords(e));
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'lang':  toggleLang();         break;
    case 'block': breakBlock();         break;
    case 'shard': selectShard(hit.id);  break;
    case 'bin':   trySortShard(hit.index); break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('knack-lang', lang);
}

// ── Draw functions ────────────────────────────────────────────────────────
function drawHeader() {
  // Title
  ctx.fillStyle    = TEXT_HI;
  ctx.font         = 'bold 22px system-ui';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign    = 'left';
  ctx.fillText('knack!', 22, 46);

  // Lang button
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 6);
  ctx.stroke();

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawGem(now) {
  // Hexagon vertices – pointy-top orientation
  const verts = Array.from({ length: 6 }, (_, i) => {
    const a = (i * 60 - 90) * Math.PI / 180;
    return [GEM_CX + GEM_R * Math.cos(a), GEM_CY + GEM_R * Math.sin(a)];
  });

  const isComplete = gemCompleteAt > 0 && now - gemCompleteAt < 1800;
  const flash      = isComplete ? Math.sin(clamp01((now - gemCompleteAt) / 1800) * Math.PI) : 0;

  if (flash > 0) { ctx.shadowColor = '#fff'; ctx.shadowBlur = 28 * flash; }

  // Draw 6 facets
  for (let i = 0; i < GEM_FACETS; i++) {
    const target  = isComplete ? 0.85 : (i < state.gem.filled ? 0.85 : 0.1);
    facetAnim[i] += (target - facetAnim[i]) * 0.08;

    ctx.globalAlpha = facetAnim[i];
    ctx.fillStyle   = FACET_COLORS[i];
    ctx.beginPath();
    ctx.moveTo(GEM_CX, GEM_CY);
    ctx.lineTo(verts[i][0], verts[i][1]);
    ctx.lineTo(verts[(i + 1) % 6][0], verts[(i + 1) % 6][1]);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur  = 0;

  // Hexagon outline
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  verts.forEach(([x, y], i) => i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y));
  ctx.closePath();
  ctx.stroke();

  // Label
  ctx.fillStyle    = TEXT_DIM;
  ctx.font         = '11px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(
    isComplete ? t('gem_done') : t('gem_label', state.gem.filled, GEM_FACETS),
    GEM_CX, GEM_CY + GEM_R + 20
  );
  ctx.textAlign = 'left';
}

function drawBlock(now) {
  if (state.phase !== 'block' || !state.block) return;

  const t  = clamp01((now - blockEnterStart) / 300);
  const sc = easeOutBack(t);
  const hw = BLOCK_SIZE / 2 * sc;
  const r  = BLOCK_R * sc;

  ctx.shadowColor = state.block.color.hex;
  ctx.shadowBlur  = 24;
  ctx.fillStyle   = state.block.color.hex;
  ctx.beginPath();
  ctx.roundRect(PLAY_CX - hw, PLAY_CY - hw, hw * 2, hw * 2, r);
  ctx.fill();
  ctx.shadowBlur  = 0;
}

function drawShards(now) {
  for (const shard of state.shards) {
    const a = shardAnim(shard, now);
    if (a.opacity < 0.01) continue;

    const s   = SHARD_SIZE * a.scale;
    const pts = shard.poly.map(([nx, ny]) => [a.x + (nx - 0.5) * s, a.y + (ny - 0.5) * s]);

    ctx.globalAlpha = a.opacity;
    if (shard.phase === 'selected') { ctx.shadowColor = shard.color.hex; ctx.shadowBlur = 14; }

    ctx.fillStyle = shard.color.hex;
    ctx.beginPath();
    pts.forEach(([x, y], i) => i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y));
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 3; i++) {
    const bin  = state.bins[i];
    const bx   = BIN_LEFT + i * (BIN_W + BIN_GAP);
    const by   = BIN_Y;

    // Animate fill level
    const fillTarget   = bin.count / BIN_CAPACITY;
    binFillAnim[i]    += (fillTarget - binFillAnim[i]) * 0.15;

    // Flash factor (0–1) after bin fills
    const flashAge    = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash       = flashAge < 600 ? 1 - flashAge / 600 : 0;

    // Background
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.fill();

    // Fill bar – clipped to bin shape
    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.4 + flash * 0.45;
      ctx.fillStyle   = bin.color.hex;
      const fillH     = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Border (glows on flash)
    if (flash > 0) { ctx.shadowColor = bin.color.hex; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = bin.color.hex + (flash > 0 ? 'ff' : '99');
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.stroke();
    ctx.shadowBlur  = 0;
  }
}

// ── Game loop ─────────────────────────────────────────────────────────────
function draw(now) {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  drawHeader();
  drawGem(now);
  drawBlock(now);
  drawShards(now);
  drawBins(now);

  requestAnimationFrame(draw);
}

// ── Boot ──────────────────────────────────────────────────────────────────
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

spawnBlock();
requestAnimationFrame(draw);
</script>

</body>
</html>

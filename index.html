<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>knack!</title>
  <link rel="icon" href="icon.svg">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="knack!">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      overflow: hidden;
      height: 100%;
    }

    body {
      background: #0d1117;
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    canvas {
      display: block;
      border-radius: 12px;
      box-shadow: 0 0 0 1px #30363d;
      width: min(430px, 100vw, calc(100dvh * 430 / 932));
      height: auto;
      aspect-ratio: 430 / 932;
      cursor: pointer;
      touch-action: none;
    }

    /* On actual phone: no frame */
    @media (max-width: 430px) {
      canvas {
        border-radius: 0;
        box-shadow: none;
      }
    }
  </style>
</head>
<body>

<canvas id="game" width="430" height="932"></canvas>

<script>
// ── Canvas setup ───────────────────────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');
const W = 430, H = 932;

const DPR = Math.min(window.devicePixelRatio || 1, 3);
canvas.width  = W * DPR;
canvas.height = H * DPR;
ctx.scale(DPR, DPR);

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const src  = e.changedTouches ? e.changedTouches[0] : e;
  return {
    x: (src.clientX - rect.left) * (W / rect.width),
    y: (src.clientY - rect.top)  * (H / rect.height),
  };
}

// ── i18n ──────────────────────────────────────────────────────────────────
const STRINGS = {
  de: {
    lang_toggle:          'EN',
    building_one:         '✦ blume wächst …',
    building_many:        (n) => `✦ ${n} blumen wachsen …`,
    building_idle_mine:   'scherben abbauen um blumen zu erschaffen',
    building_idle_garden: 'geh zur mine um scherben abzubauen',
    go_mine:              'zur Mine →',
    go_garden:            '← Garten',
  },
  en: {
    lang_toggle:          'DE',
    building_one:         '✦ flower growing …',
    building_many:        (n) => `✦ ${n} flowers growing …`,
    building_idle_mine:   'mine shards to grow flowers',
    building_idle_garden: 'go to the mine to mine shards',
    go_mine:              'to Mine →',
    go_garden:            '← Garden',
  },
};

let lang = localStorage.getItem('knack-lang') ||
  (navigator.language.startsWith('de') ? 'de' : 'en');

function t(key, ...args) {
  const v = STRINGS[lang][key];
  return typeof v === 'function' ? v(...args) : v;
}

// ── Colors ─────────────────────────────────────────────────────────────────
const COLORS = [
  { id: 'blue',   hex: '#58a6ff' },
  { id: 'orange', hex: '#f0883e' },
  { id: 'purple', hex: '#bc8cff' },
];

// Flower recipe – how many sorted shards per bin make one flower part
const FLOWER_RECIPE = { circle: 1, heart: 8, stem: 3, leaf: 2 };
const BUILD_BASE_MS = 20000;   // base build time in ms (±15% random variance)
const DONE_MAX      = 30;      // max finished flowers kept in memory

// Garden row system – 5 rows from front (0) to back (4)
const GARDEN_ROWS = [
  { yMin: 830, yMax: 870, scaleMin: 2.0, scaleMax: 2.5, opacity: 1.00 },
  { yMin: 710, yMax: 750, scaleMin: 1.4, scaleMax: 1.8, opacity: 0.95 },
  { yMin: 590, yMax: 630, scaleMin: 1.0, scaleMax: 1.3, opacity: 0.88 },
  { yMin: 470, yMax: 510, scaleMin: 0.6, scaleMax: 0.9, opacity: 0.80 },
  { yMin: 340, yMax: 380, scaleMin: 0.3, scaleMax: 0.55, opacity: 0.70 },
];
let   flowerIdCounter = 0;

const BG       = '#0d1117';
const BORDER   = '#30363d';
const TEXT_HI  = '#f0f6fc';
const TEXT_DIM = '#6e7681';

// ── Shapes ─────────────────────────────────────────────────────────────────
const SHAPES = [
  { id: 'circle' },
  { id: 'heart'  },
  { id: 'stem'   },
  { id: 'leaf'   },
];

// Weighted shape spawn – probabilities match recipe ratios (total 14 parts)
const SHAPE_WEIGHTS = [
  { shape: SHAPES[0], w: 1 },   // circle  1/14
  { shape: SHAPES[1], w: 8 },   // heart   8/14
  { shape: SHAPES[2], w: 3 },   // stem    3/14
  { shape: SHAPES[3], w: 2 },   // leaf    2/14
];
const SHAPE_WEIGHT_TOTAL = SHAPE_WEIGHTS.reduce((s, e) => s + e.w, 0);

function randomShape() {
  let r = Math.random() * SHAPE_WEIGHT_TOTAL;
  for (const entry of SHAPE_WEIGHTS) {
    r -= entry.w;
    if (r <= 0) return entry.shape;
  }
  return SHAPE_WEIGHTS[SHAPE_WEIGHTS.length - 1].shape;
}

// ── Layout ─────────────────────────────────────────────────────────────────
const HEADER_H  = 70;
const GEM_H     = 130;
const BIN_H     = 96,  BIN_W = 80, BIN_GAP = 12, BIN_R = 12;
const BIN_Y     = H - 36 - BIN_H;
const BIN_TOTAL = 4 * BIN_W + 3 * BIN_GAP;             // 356
const BIN_LEFT  = (W - BIN_TOTAL) / 2;                 // 37
const PLAY_Y    = HEADER_H + GEM_H;                    // 200
const PLAY_H    = BIN_Y - PLAY_Y - 20;                 // 580
const PLAY_CX   = W / 2;                               // 215
const PLAY_CY   = PLAY_Y + PLAY_H / 2;                 // 490
const GEM_CX    = W / 2;
const GEM_CY    = HEADER_H + GEM_H / 2 - 10;           // 125
const GEM_R     = 38;

// Shard landing zones – offsets from play-area center (12 for jackpot blocks)
const SHARD_ZONES = [
  { dx:    0, dy: -115 },
  { dx: -100, dy:  -55 },
  { dx: -100, dy:   60 },
  { dx:    0, dy:  115 },
  { dx:  100, dy:   60 },
  { dx:  100, dy:  -55 },
  { dx:  -45, dy: -160 },
  { dx:   45, dy: -155 },
  { dx: -160, dy:   10 },
  { dx:  155, dy:   15 },
  { dx:  -55, dy:  165 },
  { dx:   60, dy:  160 },
];

const SHARD_SIZE = 60;

// Block sizes – size = yield + hardness. Bigger = more taps + more shards.
const SIZES = [
  { id: 'small',   blockPx:  90, shards:  3, taps: [1,  2] },
  { id: 'medium',  blockPx: 118, shards:  5, taps: [2,  4] },
  { id: 'large',   blockPx: 150, shards:  7, taps: [4,  7] },
  { id: 'jackpot', blockPx: 188, shards: 12, taps: [7, 12] },
];


// ── Easing ────────────────────────────────────────────────────────────────
function easeOutBack(t) {
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
}
function lerp(a, b, t)  { return a + (b - a) * t; }
function clamp(t, a, b) { return Math.max(a, Math.min(b, t)); }
function clamp01(t)     { return clamp(t, 0, 1); }

// ── Haptics ───────────────────────────────────────────────────────────────
function haptic(pattern) {
  if (navigator.vibrate) navigator.vibrate(pattern);
}

// ── Screen state ──────────────────────────────────────────────────────────
let screen = 'garden'; // 'garden' | 'mine'

// Button bounds – set each frame during draw, used by hitTest
let langBtnBounds   = null;
let mineBtnBounds   = null;
let gardenBtnBounds = null;

// ── Drag state ────────────────────────────────────────────────────────────
const drag = {
  active:  false,
  shardId: null,
  x:       0,
  y:       0,
};

// ── Game state ────────────────────────────────────────────────────────────
let shardIdCounter = 0;

const state = {
  phase:    'block',   // 'block' | 'shards'
  block:    null,
  shards:   [],
  selected: null,
  bins:     SHAPES.map(s => ({ shape: s, shards: [] })),
};

// Flower system – separate from game state
const flowers = {
  building: [],   // { id, startedAt, completesAt, parts }
  done:     [],   // { ...building, x, y, rotation, scale, zIndex }
};

// ── Animation state ───────────────────────────────────────────────────────
let blockEnterStart = 0;
const binFillAnim   = Array(4).fill(0);  // lerps toward current cycle fill (0–1)
const binFlashAt    = Array(4).fill(0);  // timestamp of last recipe-threshold event

// ── Game logic ────────────────────────────────────────────────────────────
function jitter(v, range = 22) {
  return v + (Math.random() - 0.5) * range;
}

// Piece positions for N shapes in a cluster – normalized offsets scaled by spread
const PIECE_LAYOUTS = {
   3: [[ 0,   -1  ], [-0.9,  0.7 ], [ 0.9,  0.7 ]],
   5: [[ 0,   -1  ], [-0.95,-0.3 ], [-0.6,  0.85], [ 0.6,  0.85], [ 0.95,-0.3 ]],
   7: [[ 0,    0  ], [ 0,   -1.3 ], [ 1.1, -0.65], [ 1.1,  0.65], [ 0,   1.3 ], [-1.1, 0.65], [-1.1, -0.65]],
  12: [[-0.6, -0.6], [ 0.6, -0.6 ], [-0.6,  0.6 ], [ 0.6,  0.6 ],
       [ 0,   -1.4], [ 1.2, -0.7 ], [ 1.4,  0   ], [ 1.2,  0.7 ],
       [ 0,    1.4], [-1.2,  0.7 ], [-1.4,  0   ], [-1.2, -0.7 ]],
};

function genPieces(count, blockPx) {
  const spread    = blockPx * 0.17;
  const pieceSize = blockPx * 0.58;
  return PIECE_LAYOUTS[count].map(([nx, ny]) => ({
    shape: randomShape(),
    x:     nx * spread + (Math.random() - 0.5) * spread * 0.3,
    y:     ny * spread + (Math.random() - 0.5) * spread * 0.3,
    size:  pieceSize,
    angle: (Math.random() - 0.5) * 0.5,   // ±~15°
  }));
}

function spawnBlock() {
  state.phase    = 'block';
  state.shards   = [];
  state.selected = null;

  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  const size  = SIZES[Math.floor(Math.random() * SIZES.length)];
  const [tMin, tMax] = size.taps;
  const tapsRequired = tMin + Math.floor(Math.random() * (tMax - tMin + 1));

  state.block    = {
    color, size,
    pieces:       genPieces(size.shards, size.blockPx),
    tapsRequired, tapsLeft: tapsRequired,
    lastTapAt: 0, angle: 0,
  };
  blockEnterStart = performance.now();
}


function tapBlock() {
  if (state.phase !== 'block') return;
  const block = state.block;

  block.lastTapAt    = performance.now();
  block.angle += (Math.random() - 0.5) * 0.25;
  block.tapsLeft--;

  if (block.tapsLeft <= 0) {
    haptic([10, 20, 10]);
    doBreakBlock();
  } else {
    haptic(8);
  }
}

function doBreakBlock() {
  if (state.phase !== 'block') return;

  state.phase = 'shards';
  const now   = performance.now();
  const color = state.block.color;
  const zones = [...SHARD_ZONES].sort(() => Math.random() - 0.5);

  state.block.pieces.forEach((piece, i) => {
    state.shards.push({
      id:         shardIdCounter++,
      color,
      shape:      piece.shape,
      targetX:    PLAY_CX + jitter(zones[i].dx),
      targetY:    PLAY_CY + jitter(zones[i].dy),
      flyStart:   now,
      phase:      'flying',
      sortStart:  0,
      shakeStart: 0,
    });
  });
}

function selectShard(id) {
  haptic(8);

  if (state.selected === id) {
    // Tap same shard → deselect
    const s = state.shards.find(s => s.id === id);
    if (s) s.phase = 'idle';
    state.selected = null;
    return;
  }

  // Deselect previous
  if (state.selected !== null) {
    const prev = state.shards.find(s => s.id === state.selected);
    if (prev) prev.phase = 'idle';
  }

  state.selected = id;
  const shard = state.shards.find(s => s.id === id);
  if (shard) shard.phase = 'selected';
}

function trySortShard(binIndex) {
  if (state.selected === null) return;

  const shard = state.shards.find(s => s.id === state.selected);
  if (!shard) return;

  if (shard.shape.id !== state.bins[binIndex].shape.id) {
    haptic([8, 30, 8]);
    shard.shakeStart = performance.now();
    return;
  }

  // ✓ Correct sort
  haptic(12);
  shard.phase     = 'sorting';
  shard.sortStart = performance.now();
  state.selected  = null;

  setTimeout(() => {
    state.shards = state.shards.filter(s => s.id !== shard.id);

    const bin    = state.bins[binIndex];
    const recipe = FLOWER_RECIPE[bin.shape.id];
    bin.shards.push({ color: shard.color.hex });

    // Flash when we cross a recipe threshold
    if (bin.shards.length % recipe === 0) {
      binFlashAt[binIndex] = performance.now();
      haptic([18, 10, 18]);
    }

    checkBuildTrigger();

    if (state.shards.length === 0) {
      setTimeout(spawnBlock, 350);
    }
  }, 230);
}

// ── Flower system ─────────────────────────────────────────────────────────
function flowersReady() {
  return Math.min(...SHAPES.map(s => {
    const bin = state.bins.find(b => b.shape.id === s.id);
    return Math.floor(bin.shards.length / FLOWER_RECIPE[s.id]);
  }));
}

function checkBuildTrigger() {
  const MAX_BUILDING = 3;
  while (flowersReady() > 0 && flowers.building.length < MAX_BUILDING) {
    startBuildingFlower();
  }
}

function startBuildingFlower() {
  const parts = {};
  for (const s of SHAPES) {
    const bin = state.bins.find(b => b.shape.id === s.id);
    parts[s.id] = bin.shards.splice(0, FLOWER_RECIPE[s.id]);
  }
  const now     = performance.now();
  const buildMs = BUILD_BASE_MS * (0.85 + Math.random() * 0.3);
  flowers.building.push({ id: flowerIdCounter++, startedAt: now, completesAt: now + buildMs, parts });
  haptic([15, 10, 15]);
}

function tickBuilding(now) {
  const done = flowers.building.filter(f => now >= f.completesAt);
  if (!done.length) return;

  flowers.building = flowers.building.filter(f => now < f.completesAt);

  for (const flower of done) {
    const rowIndex = Math.floor(Math.random() * GARDEN_ROWS.length);
    const row      = GARDEN_ROWS[rowIndex];
    const scale    = row.scaleMin + Math.random() * (row.scaleMax - row.scaleMin);
    flowers.done.push({
      ...flower,
      x:        -60 + Math.random() * (W + 120),            // can bleed off edges
      y:        row.yMin + Math.random() * (row.yMax - row.yMin),
      rotation: (Math.random() - 0.5) * 0.3,
      scale,
      opacity:  row.opacity,
      zIndex:   rowIndex + Math.random() * 0.5,             // back rows = low zIndex
    });
  }
  while (flowers.done.length > DONE_MAX) flowers.done.shift();

  haptic([20, 12, 20, 12, 35]);
  checkBuildTrigger();
}

// ── Shard animation helper ────────────────────────────────────────────────
// Returns { x, y, scale, opacity } for the current frame
function shardAnim(shard, now) {
  if (shard.phase === 'flying') {
    const t = clamp01((now - shard.flyStart) / 450);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(PLAY_CX, shard.targetX, e),
      y:       lerp(PLAY_CY, shard.targetY, e),
      scale:   clamp01(t * 2.5),
      opacity: clamp01(t * 3),
    };
  }

  if (shard.phase === 'sorting') {
    const t = clamp01((now - shard.sortStart) / 220);
    return { x: shard.targetX, y: shard.targetY, scale: lerp(1, 0.2, t), opacity: 1 - t };
  }

  if (shard.phase === 'dragging') {
    return { x: drag.x, y: drag.y, scale: 1.18, opacity: 1 };
  }

  if (shard.phase === 'snapping') {
    const t = clamp01((now - shard.snapStart) / 280);
    const e = easeOutBack(t);
    if (t >= 1) shard.phase = 'idle';
    return {
      x:       lerp(shard.snapFrom.x, shard.targetX, e),
      y:       lerp(shard.snapFrom.y, shard.targetY, e),
      scale:   lerp(1.18, 1, t),
      opacity: 1,
    };
  }

  // idle / selected – optional shake
  let shakeX = 0;
  if (shard.shakeStart) {
    const st = clamp01((now - shard.shakeStart) / 350);
    shakeX = Math.sin(st * Math.PI * 4.5) * 12 * (1 - st);
    if (st >= 1) shard.shakeStart = 0;
  }

  return { x: shard.targetX + shakeX, y: shard.targetY, scale: 1, opacity: 1 };
}

// ── Shape paths ───────────────────────────────────────────────────────────
function pathCircle(ctx, cx, cy, s) {
  ctx.arc(cx, cy, s * 0.42, 0, Math.PI * 2);
}

function pathHeart(ctx, cx, cy, s) {
  const r = s * 0.42;
  const x = cx, y = cy + r * 0.2;
  ctx.moveTo(x, y + r * 0.75);
  ctx.bezierCurveTo(x - r * 0.1, y + r * 0.4,  x - r, y + r * 0.1,  x - r, y - r * 0.3);
  ctx.bezierCurveTo(x - r, y - r,               x,     y - r * 0.65, x,     y - r * 0.1);
  ctx.bezierCurveTo(x,     y - r * 0.65,        x + r, y - r,        x + r, y - r * 0.3);
  ctx.bezierCurveTo(x + r, y + r * 0.1,         x + r * 0.1, y + r * 0.4, x, y + r * 0.75);
}

function pathStem(ctx, cx, cy, s) {
  const w = s * 0.22, h = s * 0.46;
  ctx.roundRect(cx - w, cy - h, w * 2, h * 2, w);
}

function pathLeaf(ctx, cx, cy, s) {
  const h = s * 0.46, w = s * 0.28;
  ctx.moveTo(cx - h, cy);
  ctx.bezierCurveTo(cx - h * 0.3, cy - w, cx + h * 0.3, cy - w, cx + h, cy);
  ctx.bezierCurveTo(cx + h * 0.3, cy + w, cx - h * 0.3, cy + w, cx - h, cy);
}

function drawShapePath(ctx, shape, cx, cy, size) {
  ctx.beginPath();
  switch (shape.id) {
    case 'circle': pathCircle(ctx, cx, cy, size); break;
    case 'heart':  pathHeart(ctx, cx, cy, size);  break;
    case 'stem':   pathStem(ctx, cx, cy, size);   break;
    case 'leaf':   pathLeaf(ctx, cx, cy, size);   break;
  }
  ctx.closePath();
}

// ── Hit testing ───────────────────────────────────────────────────────────

function inRect(x, y, rx, ry, rw, rh) {
  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;
}

function hitTest(x, y, now) {
  // Lang button – both screens
  if (langBtnBounds && inRect(x, y, langBtnBounds.x, langBtnBounds.y, langBtnBounds.w, langBtnBounds.h)) {
    return { type: 'lang' };
  }

  if (screen === 'garden') {
    if (mineBtnBounds && inRect(x, y, mineBtnBounds.x, mineBtnBounds.y, mineBtnBounds.w, mineBtnBounds.h)) {
      return { type: 'mine_btn' };
    }
    return null;
  }

  // Mine screen
  if (gardenBtnBounds && inRect(x, y, gardenBtnBounds.x, gardenBtnBounds.y, gardenBtnBounds.w, gardenBtnBounds.h)) {
    return { type: 'garden_btn' };
  }

  // Shards (reverse so topmost is checked first)
  if (state.phase === 'shards') {
    for (const shard of [...state.shards].reverse()) {
      if (shard.phase === 'sorting') continue;
      const a  = shardAnim(shard, now);
      const dx = x - a.x, dy = y - a.y;
      if (Math.sqrt(dx * dx + dy * dy) < SHARD_SIZE * 0.45 * a.scale) {
        return { type: 'shard', id: shard.id };
      }
    }
  }

  // Block
  if (state.phase === 'block') {
    const hw = state.block.size.blockPx / 2;
    if (inRect(x, y, PLAY_CX - hw, PLAY_CY - hw, state.block.size.blockPx, state.block.size.blockPx)) {
      return { type: 'block' };
    }
  }

  // Bins
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(x, y, bx, BIN_Y, BIN_W, BIN_H)) return { type: 'bin', index: i };
  }

  return null;
}

// ── Input ─────────────────────────────────────────────────────────────────
let lastTouchEnd = 0;

function initDrag(coords) {
  if (screen !== 'mine') return;
  const now = performance.now();
  const hit = hitTest(coords.x, coords.y, now);
  if (!hit || hit.type !== 'shard') return;

  const shard = state.shards.find(s => s.id === hit.id);
  if (!shard || shard.phase === 'sorting') return;

  haptic(8);
  drag.active  = true;
  drag.shardId = hit.id;
  drag.x       = coords.x;
  drag.y       = coords.y;
  shard.phase  = 'dragging';
  state.selected = null;
}

function updateDrag(coords) {
  if (!drag.active) return;
  drag.x = coords.x;
  drag.y = coords.y;
}

function endDrag(coords) {
  if (!drag.active) return;
  drag.active = false;

  const shard = state.shards.find(s => s.id === drag.shardId);
  drag.shardId = null;
  if (!shard) return;

  // Check if dropped on a bin
  let binIndex = -1;
  for (let i = 0; i < 4; i++) {
    const bx = BIN_LEFT + i * (BIN_W + BIN_GAP);
    if (inRect(coords.x, coords.y, bx, BIN_Y, BIN_W, BIN_H)) { binIndex = i; break; }
  }

  if (binIndex >= 0) {
    state.selected = shard.id;
    trySortShard(binIndex);
    // trySortShard sets phase='sorting' on success – if still 'dragging', it failed
  }

  // Snap back if not successfully sorted
  if (shard.phase === 'dragging') {
    shard.snapFrom  = { x: drag.x, y: drag.y };
    shard.snapStart = performance.now();
    shard.phase     = 'snapping';
    state.selected  = null;
  }
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  initDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updateDrag(canvasCoords(e));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  lastTouchEnd = Date.now();
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
}, { passive: false });

canvas.addEventListener('mousedown',  (e) => { initDrag(canvasCoords(e)); });
canvas.addEventListener('mousemove',  (e) => { updateDrag(canvasCoords(e)); });
canvas.addEventListener('mouseup',    (e) => {
  if (Date.now() - lastTouchEnd < 500) return;
  const coords = canvasCoords(e);
  if (drag.active) { endDrag(coords); } else { handleTap(coords); }
});

function handleTap({ x, y }) {
  const now = performance.now();
  const hit = hitTest(x, y, now);
  if (!hit) return;
  switch (hit.type) {
    case 'lang':       toggleLang();       break;
    case 'mine_btn':   screen = 'mine';    break;
    case 'garden_btn': screen = 'garden';  break;
    case 'block':      tapBlock();         break;
  }
}

function toggleLang() {
  lang = lang === 'de' ? 'en' : 'de';
  localStorage.setItem('knack-lang', lang);
}

// ── Flower draw ───────────────────────────────────────────────────────────
function drawFlower(ctx, cx, cy, rotation, scale, parts) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  ctx.scale(scale, scale);
  ctx.translate(0, -58); // origin = bottom of stem

  // Extract colors (with fallbacks)
  const circleColor = parts.circle && parts.circle[0] ? parts.circle[0].color : '#58a6ff';
  const heartColors = parts.heart || [];
  const stemColors  = parts.stem  || [];
  const leafColors  = parts.leaf  || [];
  const hc = i => heartColors[i] ? heartColors[i].color : '#f0883e';
  const sc = i => stemColors[i]  ? stemColors[i].color  : '#bc8cff';
  const lc = i => leafColors[i]  ? leafColors[i].color  : '#58a6ff';

  // ── Right leaf behind stem – outer tip points upper-right ──
  ctx.save();
  ctx.translate(10, 44);
  ctx.rotate(-0.8);
  ctx.fillStyle = lc(1);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // ── Stem (3 segments as stroked lines – guaranteed connected, per-segment color) ──
  const kinks = [ {x:2,y:15}, {x:7,y:30}, {x:0,y:45}, {x:3,y:58} ];
  ctx.lineWidth = 5;
  ctx.lineCap   = 'round';
  ctx.lineJoin  = 'round';
  for (let i = 0; i < 3; i++) {
    ctx.beginPath();
    ctx.strokeStyle = sc(i);
    ctx.moveTo(kinks[i].x,   kinks[i].y);
    ctx.lineTo(kinks[i+1].x, kinks[i+1].y);
    ctx.stroke();
  }
  ctx.lineCap  = 'butt';
  ctx.lineJoin = 'miter';

  // ── Left leaf in front of stem – outer tip points upper-left ──
  ctx.save();
  ctx.translate(-8, 30);
  ctx.rotate(0.8);
  ctx.fillStyle = lc(0);
  ctx.beginPath(); pathLeaf(ctx, 0, 0, 30); ctx.closePath(); ctx.fill();
  ctx.restore();

  // ── Petal base – solid circle to block bleed-through from behind ──
  ctx.fillStyle = hc(0);
  ctx.beginPath(); pathCircle(ctx, 0, 0, 27); ctx.fill();

  // ── Petals: 8 hearts in a ring, tips toward center ──
  const PETAL_R    = 17;
  const PETAL_SIZE = 20;
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
    ctx.save();
    ctx.translate(Math.cos(angle) * PETAL_R, Math.sin(angle) * PETAL_R);
    ctx.rotate(angle + Math.PI / 2);   // rotate so tip points toward center
    ctx.fillStyle = hc(i);
    ctx.beginPath(); pathHeart(ctx, 0, 0, PETAL_SIZE); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // ── Center circle ──
  ctx.fillStyle = circleColor;
  ctx.beginPath(); pathCircle(ctx, 0, 0, 14); ctx.fill();

  ctx.restore();
}

// ── Sky (Garden background) ───────────────────────────────────────────────
function drawSky() {
  // Gradient: dark purple-black at zenith → warm summer-evening purple at horizon
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0a0817');
  grad.addColorStop(1, '#2a1854');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Clouds: subtle puffs of overlapping circles, fixed positions, upper 55% of screen
  const CLOUDS = [
    { cx:  75, cy: 105, puffs: [{ dx: -28, dy:  8, r: 28 }, { dx:  0, dy:  0, r: 35 }, { dx: 28, dy: 10, r: 26 }, { dx: 12, dy: 18, r: 20 }] },
    { cx: 310, cy: 155, puffs: [{ dx: -32, dy: 12, r: 24 }, { dx:  0, dy:  0, r: 34 }, { dx: 30, dy:  8, r: 28 }, { dx: 14, dy: 16, r: 18 }] },
    { cx: 165, cy: 255, puffs: [{ dx: -25, dy:  6, r: 22 }, { dx:  0, dy:  0, r: 30 }, { dx: 24, dy:  8, r: 20 }] },
    { cx: 368, cy: 345, puffs: [{ dx: -22, dy:  5, r: 20 }, { dx:  0, dy:  0, r: 28 }, { dx: 20, dy:  8, r: 18 }, { dx: 10, dy: 14, r: 14 }] },
    { cx:  52, cy: 405, puffs: [{ dx: -20, dy:  5, r: 18 }, { dx:  0, dy:  0, r: 26 }, { dx: 18, dy:  6, r: 16 }] },
  ];

  ctx.fillStyle = 'rgba(255,255,255,0.055)';
  for (const cloud of CLOUDS) {
    for (const p of cloud.puffs) {
      ctx.beginPath();
      ctx.arc(cloud.cx + p.dx, cloud.cy + p.dy, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ── Garden flowers ────────────────────────────────────────────────────────
function drawGardenFlowers() {
  const sorted = [...flowers.done].sort((a, b) => a.zIndex - b.zIndex);
  for (const flower of sorted) {
    ctx.globalAlpha = flower.opacity ?? 1;
    drawFlower(ctx, flower.x, flower.y, flower.rotation, flower.scale, flower.parts);
    ctx.globalAlpha = 1;
  }
}

// ── Draw functions ────────────────────────────────────────────────────────


function drawIndicator(now) {
  const active  = flowers.building.length > 0;
  const current = flowers.building[0];
  const cx = GEM_CX, cy = GEM_CY, r = GEM_R;

  // Progress through current build (0–1)
  const progress = current
    ? clamp01((now - current.startedAt) / (current.completesAt - current.startedAt))
    : 0;

  // Pulse factor (only when active)
  const pulse = active ? 0.6 + 0.4 * Math.sin(now / 700) : 0;

  // Background fill
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = active ? `rgba(88,166,255,${0.05 + pulse * 0.05})` : 'rgba(110,118,129,0.05)';
  ctx.fill();

  // Track ring
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.strokeStyle = BORDER;
  ctx.lineWidth   = 3;
  ctx.stroke();

  // Progress arc
  if (active) {
    ctx.shadowColor = '#58a6ff';
    ctx.shadowBlur  = 10 + 8 * pulse;
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    ctx.strokeStyle = '#58a6ff';
    ctx.lineWidth   = 3;
    ctx.lineCap     = 'round';
    ctx.stroke();
    ctx.shadowBlur  = 0;
    ctx.lineCap     = 'butt';
  }

  // Center dot
  ctx.beginPath();
  ctx.arc(cx, cy, 5, 0, Math.PI * 2);
  ctx.fillStyle = active ? `rgba(88,166,255,${0.4 + pulse * 0.6})` : 'rgba(110,118,129,0.3)';
  ctx.fill();

  // Label – context-aware
  ctx.fillStyle    = TEXT_DIM;
  ctx.font         = '11px system-ui';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'alphabetic';
  let label;
  if (flowers.building.length > 1) {
    label = t('building_many', flowers.building.length);
  } else if (flowers.building.length === 1) {
    label = t('building_one');
  } else if (screen === 'garden') {
    label = t('building_idle_garden');
  } else {
    label = t('building_idle_mine');
  }
  if (label) ctx.fillText(label, cx, cy + r + 20);
  ctx.textAlign = 'left';
}

// ── Garden draw ───────────────────────────────────────────────────────────
function drawGardenHeader() {
  ctx.fillStyle    = TEXT_HI;
  ctx.font         = 'bold 22px system-ui';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign    = 'left';
  ctx.fillText('knack!', 22, 46);

  drawLangButton();
}

function drawMineHeader() {
  // Back button left
  const label = t('go_garden');
  ctx.font         = '13px system-ui';
  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(label, 22, 35);
  const tw = ctx.measureText(label).width;
  gardenBtnBounds = { x: 18, y: 22, w: tw + 8, h: 26 };

  drawLangButton();
}

function drawLangButton() {
  const label = t('lang_toggle');
  ctx.font     = '12px system-ui';
  const tw     = ctx.measureText(label).width;
  const bw = tw + 20, bh = 26, bx = W - bw - 20, by = 22;
  langBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.strokeStyle  = BORDER;
  ctx.lineWidth    = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 6);
  ctx.stroke();

  ctx.fillStyle    = TEXT_DIM;
  ctx.textBaseline = 'middle';
  ctx.textAlign    = 'left';
  ctx.fillText(label, bx + 10, by + bh / 2);
}

function drawMineButton() {
  const label = t('go_mine');
  ctx.font     = '15px system-ui';
  const bw = 180, bh = 52, bx = W / 2 - 90, by = H - 110;
  mineBtnBounds = { x: bx, y: by, w: bw, h: bh };

  ctx.fillStyle = BORDER;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 26);
  ctx.fill();

  ctx.fillStyle    = TEXT_HI;
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, W / 2, by + bh / 2);
  ctx.textAlign = 'left';
}

function drawGarden(now) {
  drawSky();
  drawGardenHeader();
  drawGardenFlowers();
  drawIndicator(now);
  drawMineButton();
}

function drawMine(now) {
  drawMineHeader();
  drawIndicator(now);
  drawBlock(now);
  drawShards(now, false);
  drawBins(now);
  drawShards(now, true);
}

function drawBlock(now) {
  if (state.phase !== 'block' || !state.block) return;

  const block = state.block;

  // Enter animation
  const enterT  = clamp01((now - blockEnterStart) / 300);
  const enterSc = easeOutBack(enterT);

  // Tap wobble: scale punch + rotation rattle, both decay together
  const wobbleAge = block.lastTapAt > 0 ? now - block.lastTapAt : Infinity;
  const wobbleT   = wobbleAge < 220 ? clamp01(wobbleAge / 220) : 1;
  const wobbleSc  = wobbleAge < 220 ? 1 + Math.sin(wobbleT * Math.PI) * 0.09 : 1;
  const wobbleRot = block.angle;

  // Damage progress (0 = fresh, approaches 1 as taps run out)
  const progress = 1 - block.tapsLeft / block.tapsRequired;

  // Piece drift: spread further with each tap
  const drift = 1 + progress * 0.9;


  const sc = enterSc * wobbleSc;

  // Draw pieces with block-level rotation
  ctx.save();
  ctx.translate(PLAY_CX, PLAY_CY);
  ctx.rotate(wobbleRot);
  // Pass 1 – glow halo (only after first tap, doesn't blur the shapes themselves)
  if (progress > 0) {
    const pulse    = 0.55 + 0.45 * Math.sin(now / (180 - progress * 110));
    ctx.shadowColor = block.color.hex;
    ctx.shadowBlur  = progress * 34 * pulse;
    ctx.fillStyle   = block.color.hex;
    for (const piece of block.pieces) {
      ctx.save();
      ctx.translate(piece.x * sc * drift, piece.y * sc * drift);
      ctx.rotate(piece.angle);
      drawShapePath(ctx, piece.shape, 0, 0, piece.size * sc);
      ctx.fill();
      ctx.restore();
    }
    ctx.shadowBlur = 0;
  }

  // Pass 2 – sharp shapes on top
  ctx.fillStyle = block.color.hex;
  for (const piece of block.pieces) {
    ctx.save();
    ctx.translate(piece.x * sc * drift, piece.y * sc * drift);
    ctx.rotate(piece.angle);
    drawShapePath(ctx, piece.shape, 0, 0, piece.size * sc);
    ctx.fill();
    ctx.restore();
  }
  ctx.restore();


}

function drawShards(now, dragOnly = false) {
  for (const shard of state.shards) {
    const isDragged = shard.phase === 'dragging';
    if (dragOnly !== isDragged) continue;
    const a = shardAnim(shard, now);
    if (a.opacity < 0.01) continue;

    ctx.globalAlpha = a.opacity;
    if (shard.phase === 'selected' || shard.phase === 'dragging' || shard.phase === 'snapping') {
      ctx.shadowColor = shard.color.hex;
      ctx.shadowBlur  = shard.phase === 'dragging' ? 22 : 14;
    }

    ctx.fillStyle = shard.color.hex;
    drawShapePath(ctx, shard.shape, a.x, a.y, SHARD_SIZE * a.scale);
    ctx.fill();

    ctx.shadowBlur  = 0;
    ctx.globalAlpha = 1;
  }
}

function drawBins(now) {
  for (let i = 0; i < 4; i++) {
    const bin    = state.bins[i];
    const bx     = BIN_LEFT + i * (BIN_W + BIN_GAP);
    const by     = BIN_Y;
    const recipe = FLOWER_RECIPE[bin.shape.id];

    // level = total shards / recipe (e.g. 1.5 = halfway through 2nd flower's worth)
    const level      = bin.shards.length / recipe;
    const multiples  = Math.floor(level);
    // cycle: progress within current recipe (0–1). At exact multiples show 1, not 0.
    const cycle      = (level % 1) || (level > 0 ? 1 : 0);

    binFillAnim[i] += (cycle - binFillAnim[i]) * 0.15;

    // Flash factor after hitting a recipe threshold
    const flashAge = binFlashAt[i] ? now - binFlashAt[i] : Infinity;
    const flash    = flashAge < 600 ? 1 - flashAge / 600 : 0;

    // Background tint – more saturated per additional multiple
    const tintAlpha = Math.min(multiples, 3) / 3 * 0.18;
    ctx.fillStyle = BG;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.fill();

    if (tintAlpha > 0) {
      ctx.globalAlpha = tintAlpha;
      ctx.fillStyle   = '#58a6ff';
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Fill bar – shows progress within current recipe cycle
    if (binFillAnim[i] > 0.005) {
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
      ctx.clip();
      ctx.globalAlpha = 0.18 + flash * 0.35;
      ctx.fillStyle   = TEXT_HI;
      const fillH = binFillAnim[i] * BIN_H;
      ctx.fillRect(bx, by + BIN_H - fillH, BIN_W, fillH);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Border
    if (flash > 0) { ctx.shadowColor = TEXT_HI; ctx.shadowBlur = 12 * flash; }
    ctx.strokeStyle = flash > 0 ? TEXT_HI : BORDER;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.roundRect(bx, by, BIN_W, BIN_H, BIN_R);
    ctx.stroke();
    ctx.shadowBlur  = 0;

    // Shape icon
    ctx.globalAlpha = 0.3 + flash * 0.5;
    ctx.fillStyle   = TEXT_HI;
    drawShapePath(ctx, bin.shape, bx + BIN_W / 2, by + BIN_H / 2, 30);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ── Game loop ─────────────────────────────────────────────────────────────
function draw(now) {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  tickBuilding(now);

  if (screen === 'garden') {
    drawGarden(now);
  } else {
    drawMine(now);
  }

  requestAnimationFrame(draw);
}

// ── Boot ──────────────────────────────────────────────────────────────────
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// Garden flowers are populated by the row system (see DESIGN.md → Garden – Reihen-System)

spawnBlock();
requestAnimationFrame(draw);
</script>

</body>
</html>
